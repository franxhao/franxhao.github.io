{"meta":{"title":"FranxHao","subtitle":"","description":"是正在努力的学生党呀","author":"豪少super","url":"https://franxhao.top","root":"/"},"pages":[{"title":"关于","date":"2020-03-30T18:36:21.000Z","updated":"2021-06-12T12:53:04.541Z","comments":false,"path":"about/index.html","permalink":"https://franxhao.top/about/index.html","excerpt":"","text":"与你相遇是最美好的缘分 关于本站关于我站点信息 关于本站这里是我的Hexo静态站站点链接：franxhao.top驱动 - Hexo 主题 - NexT.Gemini v7.8.0托管于 Vercel站点介绍：这是我基于Hexo搭建的个人博客网站，使用NexT主题。因为机遇巧合在B站上看到了 CodeSheep 的博客搭建视频，了解到搭建博客对学习有一定的帮助后，开始下定决心要搭建一个属于自己的博客网站，希望能通过本站对专业学习的过程进行记录和分享，也方便对知识的回顾。我会在学习的同时尽力来完善和优化本站内容，也希望能给到访本站的朋友们带来帮助。关于我的Typecho动态站站点链接：haozsky.top驱动 - Typecho 主题 - handsome v7.3.1腾讯云服务器 1核 2GB 1Mbps双站点文章会同步更新欢迎前来光顾我的动态主站 关于我当前坐标：重庆本科 物联网工程 专业 ，目前处于大三学习阶段。 学习计划(Java)学习进度：Java基础部分Java核心编程、MySQL+JDBC基于控制台的图书管理系统（已完成）Java Web 部分HTML+CSS+JSjQuery、Bootstrap、Vue编写网页简历JSP+Servlet附加学习（推荐书籍）：Linux操作系统基础（《鸟哥的Linux私房菜》 第四版）C语言进阶 - 指针+内存管理（《C Primer Plus》）MySQL（《MySQL 必知必会》）数据结构与算法（《大话数据结构》、《算法》）… 站点信息2020年8月15日：关闭本站评论系统2020年8月17日：实现双线部署到 Coding Pages 和 GitHub Pages 并实现全站 HPPTS 关闭Gitee Pages的部署2021年5月10日 ：本站已迁移到 Vercel 上托管，暂停在Coding Pages上的部署相关文章：将网站迁移到Vercel托管 2021年6月12日：关闭底部 站点访问量统计 功能"},{"title":"分类","date":"2020-03-30T17:41:29.000Z","updated":"2020-04-04T15:47:07.786Z","comments":false,"path":"categories/index.html","permalink":"https://franxhao.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-30T17:15:21.000Z","updated":"2020-04-04T15:46:55.887Z","comments":false,"path":"tags/index.html","permalink":"https://franxhao.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-15T18:28:38.697Z","updated":"2020-08-15T18:18:30.209Z","comments":true,"path":"js/cursor/explosion.min.js","permalink":"https://franxhao.top/js/cursor/explosion.min.js","excerpt":"","text":"\"use strict\";function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=\"#F00\",a.radius=.1,a.alpha=.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t"},{"title":"","date":"2020-08-15T18:28:38.692Z","updated":"2020-08-15T18:18:55.823Z","comments":true,"path":"js/cursor/text.js","permalink":"https://franxhao.top/js/cursor/text.js","excerpt":"","text":"var a_idx = 0; jQuery(document).ready(function($) { $(\"body\").click(function(e) { var a = new Array(\"喜欢我\", \"不喜欢我\"); var $i = $(\"\").text(a[a_idx]); var x = e.pageX, y = e.pageY; $i.css({ \"z-index\": 99999, \"top\": y - 28, \"left\": x - a[a_idx].length * 8, \"position\": \"absolute\", \"color\": \"#ff7a45\" }); $(\"body\").append($i); $i.animate({ \"top\": y - 180, \"opacity\": 0 }, 1500, function() { $i.remove(); }); a_idx = (a_idx + 1) % a.length; }); });"},{"title":"","date":"2020-08-15T18:28:38.689Z","updated":"2020-08-15T18:18:43.912Z","comments":true,"path":"js/cursor/love.min.js","permalink":"https://franxhao.top/js/cursor/love.min.js","excerpt":"","text":"!function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e"},{"title":"","date":"2020-08-15T18:28:38.701Z","updated":"2020-08-15T18:18:01.302Z","comments":true,"path":"js/cursor/fireworks.js","permalink":"https://franxhao.top/js/cursor/fireworks.js","excerpt":"","text":"class Circle { constructor({ origin, speed, color, angle, context }) { this.origin = origin this.position = { ...this.origin } this.color = color this.speed = speed this.angle = angle this.context = context this.renderCount = 0 } draw() { this.context.fillStyle = this.color this.context.beginPath() this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2) this.context.fill() } move() { this.position.x = (Math.sin(this.angle) * this.speed) + this.position.x this.position.y = (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3) this.renderCount++ } } class Boom { constructor ({ origin, context, circleCount = 16, area }) { this.origin = origin this.context = context this.circleCount = circleCount this.area = area this.stop = false this.circles = [] } randomArray(range) { const length = range.length const randomIndex = Math.floor(length * Math.random()) return range[randomIndex] } randomColor() { const range = ['8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] return '#' + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) } randomRange(start, end) { return (end - start) * Math.random() + start } init() { for(let i = 0; i < this.circleCount; i++) { const circle = new Circle({ context: this.context, origin: this.origin, color: this.randomColor(), angle: this.randomRange(Math.PI - 1, Math.PI + 1), speed: this.randomRange(1, 6) }) this.circles.push(circle) } } move() { this.circles.forEach((circle, index) => { if (circle.position.x > this.area.width || circle.position.y > this.area.height) { return this.circles.splice(index, 1) } circle.move() }) if (this.circles.length == 0) { this.stop = true } } draw() { this.circles.forEach(circle => circle.draw()) } } class CursorSpecialEffects { constructor() { this.computerCanvas = document.createElement('canvas') this.renderCanvas = document.createElement('canvas') this.computerContext = this.computerCanvas.getContext('2d') this.renderContext = this.renderCanvas.getContext('2d') this.globalWidth = window.innerWidth this.globalHeight = window.innerHeight this.booms = [] this.running = false } handleMouseDown(e) { const boom = new Boom({ origin: { x: e.clientX, y: e.clientY }, context: this.computerContext, area: { width: this.globalWidth, height: this.globalHeight } }) boom.init() this.booms.push(boom) this.running || this.run() } handlePageHide() { this.booms = [] this.running = false } init() { const style = this.renderCanvas.style style.position = 'fixed' style.top = style.left = 0 style.zIndex = '999999999999999999999999999999999999999999' style.pointerEvents = 'none' style.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth style.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight document.body.append(this.renderCanvas) window.addEventListener('mousedown', this.handleMouseDown.bind(this)) window.addEventListener('pagehide', this.handlePageHide.bind(this)) } run() { this.running = true if (this.booms.length == 0) { return this.running = false } requestAnimationFrame(this.run.bind(this)) this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.booms.forEach((boom, index) => { if (boom.stop) { return this.booms.splice(index, 1) } boom.move() boom.draw() }) this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight) } } const cursorSpecialEffects = new CursorSpecialEffects() cursorSpecialEffects.init()"},{"title":"","date":"2020-08-15T19:03:04.892Z","updated":"2020-08-15T19:03:04.892Z","comments":true,"path":"js/custom/clock.js","permalink":"https://franxhao.top/js/custom/clock.js","excerpt":"","text":"(function () { var digit = [ [ [0, 0, 1, 1, 1, 0, 0], [0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [0, 1, 1, 0, 1, 1, 0], [0, 0, 1, 1, 1, 0, 0] ],//0 [ [0, 0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1] ],//1 [ [0, 1, 1, 1, 1, 1, 0], [1, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1, 1] ],//2 [ [1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0] ],//3 [ [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0], [0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 0, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1] ],//4 [ [1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0] ],//5 [ [0, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0] ],//6 [ [1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0] ],//7 [ [0, 1, 1, 1, 1, 1, 0], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0] ],//8 [ [0, 1, 1, 1, 1, 1, 0], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0], [0, 1, 1, 0, 0, 0, 0] ],//9 [ [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0] ]//: ]; var canvas = document.getElementById('canvasDiyBlock'); if (canvas.getContext) { var cxt = canvas.getContext('2d'); //声明canvas的宽高 var H = 100, W = 700; canvas.height = H; canvas.width = W; cxt.fillStyle = '#f00'; cxt.fillRect(10, 10, 50, 50); //存储时间数据 var data = []; //存储运动的小球 var balls = []; //设置粒子半径 var R = canvas.height / 20 - 1; (function () { var temp = /(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)/.exec(new Date()); //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成 data.push(temp[1], temp[2], 10, temp[3], temp[4], 10, temp[5], temp[6]); })(); /*生成点阵数字*/ function renderDigit(index, num) { for (var i = 0; i < digit[num].length; i++) { for (var j = 0; j < digit[num][i].length; j++) { if (digit[num][i][j] == 1) { cxt.beginPath(); cxt.arc(14 * (R + 2) * index + j * 2 * (R + 1) + (R + 1), i * 2 * (R + 1) + (R + 1), R, 0, 2 * Math.PI); cxt.closePath(); cxt.fill(); } } } } /*更新时钟*/ function updateDigitTime() { var changeNumArray = []; var temp = /(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)/.exec(new Date()); var NewData = []; NewData.push(temp[1], temp[2], 10, temp[3], temp[4], 10, temp[5], temp[6]); for (var i = data.length - 1; i >= 0; i--) { //时间发生变化 if (NewData[i] !== data[i]) { //将变化的数字值和在data数组中的索引存储在changeNumArray数组中 changeNumArray.push(i + '_' + (Number(data[i]) + 1) % 10); } } //增加小球 for (var i = 0; i < changeNumArray.length; i++) { addBalls.apply(this, changeNumArray[i].split('_')); } data = NewData.concat(); } /*更新小球状态*/ function updateBalls() { for (var i = 0; i < balls.length; i++) { balls[i].stepY += balls[i].disY; balls[i].x += balls[i].stepX; balls[i].y += balls[i].stepY; if (balls[i].x > W + R || balls[i].y > H + R) { balls.splice(i, 1); i--; } } } /*增加要运动的小球*/ function addBalls(index, num) { var numArray = [1, 2, 3]; var colorArray = [\"#3BE\", \"#09C\", \"#A6C\", \"#93C\", \"#9C0\", \"#690\", \"#FB3\", \"#F80\", \"#F44\", \"#C00\"]; for (var i = 0; i < digit[num].length; i++) { for (var j = 0; j < digit[num][i].length; j++) { if (digit[num][i][j] == 1) { var ball = { x: 14 * (R + 2) * index + j * 2 * (R + 1) + (R + 1), y: i * 2 * (R + 1) + (R + 1), stepX: Math.floor(Math.random() * 4 - 2), stepY: -2 * numArray[Math.floor(Math.random() * numArray.length)], color: colorArray[Math.floor(Math.random() * colorArray.length)], disY: 1 }; balls.push(ball); } } } } /*渲染*/ function render() { //重置画布宽度，达到清空画布的效果 canvas.height = 100; //渲染时钟 for (var i = 0; i < data.length; i++) { renderDigit(i, data[i]); } //渲染小球 for (var i = 0; i < balls.length; i++) { cxt.beginPath(); cxt.arc(balls[i].x, balls[i].y, R, 0, 2 * Math.PI); cxt.fillStyle = balls[i].color; cxt.closePath(); cxt.fill(); } } clearInterval(oTimer); var oTimer = setInterval(function () { //更新时钟 updateDigitTime(); //更新小球状态 updateBalls(); //渲染 render(); }, 50); } })();"}],"posts":[{"title":"【嵌入式STM32】（七）ADC实验","slug":"STM32-7-ADC","date":"2021-06-14T05:00:16.000Z","updated":"2021-06-14T05:35:09.937Z","comments":true,"path":"undefined/d8eae319.html","link":"","permalink":"https://franxhao.top/undefined/d8eae319.html","excerpt":"0. 实验要求掌握库函数版的ADC实验（寄存器版为自学内容） 要求使用 ADC2，通道 5，连续转换模式，时钟频率 9M，采样时间为 13.5 周期， ADC 数据左对齐，采样 5 次取平均值，显示的值取小数点后 2 位 （注：文章仅贴出修改部分代码，详细原码请下载资料包查看）","text":"0. 实验要求掌握库函数版的ADC实验（寄存器版为自学内容） 要求使用 ADC2，通道 5，连续转换模式，时钟频率 9M，采样时间为 13.5 周期， ADC 数据左对齐，采样 5 次取平均值，显示的值取小数点后 2 位 （注：文章仅贴出修改部分代码，详细原码请下载资料包查看） 1. 库函数版(1). adc.h：定义 ADC 初始化函数，声明 Get_Adc 和 Get_Adc_Average 两个函数 123456#ifndef __ADC_H#define __ADC_H #include \"sys.h\"void Adc_Init(void);u16 Get_Adc(u8 ch); u16 Get_Adc_Average(u8 ch,u8 times); (2). adc.c： 初始化 ADC2，开启通道 5，设置连续转换模式，时钟频率 9M， ADC 数据左对齐 获取 ADC 值和平均值，设置采样时间为 13.5 周期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//初始化ADC2//开启通道5 void Adc_Init(void)&#123; ADC_InitTypeDef ADC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_ADC2, ENABLE ); //使能ADC2通道时钟 //PA1 作为模拟通过输入引脚 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //通道5 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //模拟输入引脚 设置工作模式:模拟输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); RCC_ADCCLKConfig(RCC_PCLK2_Div8); //设置ADC分频因子8 72M/8=9M,ADC最大时间不能超过14M ADC_DeInit(ADC2); //复位ADC2,将外设 ADC2 的全部寄存器重设为缺省值 //初始化ADC参数 ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; //ADC工作模式:ADC1和ADC2工作在独立模式 ADC_InitStructure.ADC_ScanConvMode = DISABLE; //模数转换工作在单通道模式 不用扫描模式 单通道模式:DISABLE 多通道模式：ENABLE ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; //模数转换工作在连续转换模式 单次转换模式：DISABLE 连续转换模式：ENABLE ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //转换由软件而不是外部触发启动 ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Left; //ADC数据左对齐 ADC_InitStructure.ADC_NbrOfChannel = 1; //顺序进行规则转换的ADC通道的数目 ADC_Init(ADC2, &amp;ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器 ADC_Cmd(ADC2, ENABLE); //使能指定的ADC2 ADC_ResetCalibration(ADC2); //使能复位校准 while(ADC_GetResetCalibrationStatus(ADC2)); //等待复位校准结束 ADC_StartCalibration(ADC2); //开启AD校准 while(ADC_GetCalibrationStatus(ADC2)); //等待校准结束 // ADC_SoftwareStartConvCmd(ADC2, ENABLE); //使能指定的ADC2的软件转换启动功能&#125; //获得ADC值//ch:通道值 0~3u16 Get_Adc(u8 ch) &#123; //设置指定ADC的规则组通道，一个序列，采样时间 ADC_RegularChannelConfig(ADC2, ch, 1, ADC_SampleTime_13Cycles5 ); //ADC2,ADC通道,采样时间为13.5周期 ADC_SoftwareStartConvCmd(ADC2, ENABLE); //使能指定的ADC2的软件转换启动功能 while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC )); //等待转换结束 return ADC_GetConversionValue(ADC2); //返回最近一次ADC2规则组的转换结果&#125;u16 Get_Adc_Average(u8 ch,u8 times)&#123; u32 temp_val=0; u8 t; for(t=0;t&lt;times;t++) &#123; temp_val+=Get_Adc(ch); delay_ms(5); &#125; return temp_val/times;&#125; (3). main.c：主要修改 while 循环部分，取 ADC 平均值参数设置为通道 5 和采样 5 次平均值；在 temp*=100 中，设置为 100 是为了取小数后两位 12345678910111213while(1)&#123; adcx=Get_Adc_Average(ADC_Channel_5,5); //通道5，采样5次取平均值 LCD_ShowxNum(156,130,adcx,4,16,0); //显示ADC的值 temp=(float)adcx*(3.3/4096); adcx=temp; LCD_ShowxNum(156,150,adcx,1,16,0); //显示电压值 temp-=adcx; temp*=100; //1000取小数点后3位，100取后2位 LCD_ShowxNum(172,150,temp,3,16,0X80); LED0=!LED0; delay_ms(250); &#125; 3. 参考资料ADC实验原码下载： 网盘下载：ADC实验.zip 密码：ey1e 内容包含： 寄存器和库函数模板初始原码 按实验要求修改后的原码 嵌入式STM32学习视频： 字母站传送门：【正点原子】STM32开发板实验教程 4. 最后这是【嵌入式STM32】系列文章的最后一篇文章了，在这里做一个结束总结 关于【嵌入式STM32】是作者大三第二学期的课程，其内容是以实验课内容为主来撰写的。文章部分内容不多，所以只靠阅读文章是不够的，需要自行将提供的原码资料下载出来，通过Keil 5 来查看、对比和动手修改才能学到相应的知识 最后希望能对读者学习有帮助，祝考运昌盛！ 所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途想看更多有关【嵌入式STM32】的文章可以前往：【嵌入式STM32】文章汇总","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"嵌入式/STM32","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://franxhao.top/tags/STM32/"}]},{"title":"【嵌入式STM32】系列文章汇总","slug":"STM32-totalpost","date":"2021-06-12T12:54:33.000Z","updated":"2021-06-14T05:43:00.550Z","comments":true,"path":"undefined/64afecd0.html","link":"","permalink":"https://franxhao.top/undefined/64afecd0.html","excerpt":"嵌入式STM32——实验系列文章汇总传送门 第一篇：新建库函数版和寄存器版工程模板 第二篇：跑马灯实验 第三篇：按键亮灯实验 第四篇：串口实验 第五篇：外部中断实验 第六篇：定时器中断实验 第七篇：ADC实验","text":"嵌入式STM32——实验系列文章汇总传送门 第一篇：新建库函数版和寄存器版工程模板 第二篇：跑马灯实验 第三篇：按键亮灯实验 第四篇：串口实验 第五篇：外部中断实验 第六篇：定时器中断实验 第七篇：ADC实验 STM32中文参考手册网盘下载：STM32中文参考手册_V10.pdf 密码：axgt 【嵌入式STM32】系列文章汇总 公告 暂定于2021年6月23日 取消置顶","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"嵌入式/STM32","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://franxhao.top/tags/STM32/"}]},{"title":"【嵌入式STM32】（六）定时器中断实验","slug":"STM32-6-timer","date":"2021-06-01T04:04:47.000Z","updated":"2021-06-14T05:01:21.365Z","comments":true,"path":"undefined/c0feab90.html","link":"","permalink":"https://franxhao.top/undefined/c0feab90.html","excerpt":"0. 实验要求掌握寄存器版和库函数版的定时器中断实验 本次实验以跑马灯为基础，LED灯接端口 PC8-PC11并依次点亮，点亮时间间隔2s。使用定时器 2 中断、向下计数、2s 产生 1 次中断（溢出）；中断优先级分组为组 3，抢占优先级 4 级，响应优先级 1 级 （注：文章仅贴出修改部分代码，详细原码请下载资料包查看）","text":"0. 实验要求掌握寄存器版和库函数版的定时器中断实验 本次实验以跑马灯为基础，LED灯接端口 PC8-PC11并依次点亮，点亮时间间隔2s。使用定时器 2 中断、向下计数、2s 产生 1 次中断（溢出）；中断优先级分组为组 3，抢占优先级 4 级，响应优先级 1 级 （注：文章仅贴出修改部分代码，详细原码请下载资料包查看） 1. 寄存器版(1). timer.c： 初始化定时器 2 中断：先使能 TIM2 时钟，然后给 TIM2 设定计数器 自动重装载值 arr 和预分频器 psc，通过 DIER 寄存器允许更新中断，CR1 寄存器使能定时器 2，设置向下计数，即位 0 和位 4 置 1：00010001=0x11，最后在MY_NVIC_Init 中设置中断优先级分组为组 3，抢占优先级 4 级，响应优先级为1 定时器 2 中断服务函数：为实现跑马灯，在中断服务程序中使用 count 计数进行判断来控制 LED 的亮灭，每次中断服务结束后都需要清除中断标志位，保证下次中断计时能够从 0 开始，正常运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748unsigned int count = 0;//定时器2中断服务程序 void TIM2_IRQHandler(void)&#123; if(TIM2-&gt;SR&amp;0X0001)//溢出中断 &#123; if(count==0)&#123; LED0 = 0; LED1 = 1; LED2 = 1; LED3 = 1; count+=1; &#125;else if(count==1)&#123; LED0 = 1; LED1 = 0; LED2 = 1; LED3 = 1; count+=1; &#125;else if(count==2)&#123; LED0 = 1; LED1 = 1; LED2 = 0; LED3 = 1; count+=1; &#125;else if(count==3)&#123; LED0 = 1; LED1 = 1; LED2 = 1; LED3 = 0; count = 0; &#125; &#125; TIM2-&gt;SR&amp;=~(1&lt;&lt;0);//清除中断标志位 &#125;//通用定时器中断初始化//这里时钟选择为APB1的2倍，而APB1为36M//arr：自动重装值。//psc：时钟预分频数//这里使用的是定时器2!void TIM2_Int_Init(u16 arr,u16 psc)&#123; RCC-&gt;APB1ENR|=1&lt;&lt;0; //TIM2时钟使能 TIM2-&gt;ARR=arr; //设定计数器自动重装值 TIM2-&gt;PSC=psc; //预分频器设置 TIM2-&gt;DIER|=1&lt;&lt;0; //允许更新中断 TIM2-&gt;CR1|=0x11; //使能定时器2,向下计数,2s产生1次中断（溢出） 00010001 MY_NVIC_Init(4,1,TIM2_IRQn,3);//抢占4，子优先级1，组3&#125; (2). main.c：主函数。加入时钟 2 中断初始化函数 TIM2_Int_Init(19999,7199); 因为 APB1 的分频系数是 2，所以 APB1 为 36M，由公式 Tout=（ARR+1)(PSC+1)/Tclk 可知，为了让预分频系数能整除真正时钟 Tclk，需要给 PSC 设置为 7199，根 据要求 2s 后产生 1 次中断（时钟溢出），即跑马灯闪烁时间间隔为 2s，则将 ARR 设置为 19999 即可 123456789int main(void)&#123; Stm32_Clock_Init(9); //系统时钟设置 delay_init(72); //延时初始化 uart_init(72,9600); //串口初始化 LED_Init(); //初始化与LED连接的硬件接口 TIM2_Int_Init(19999,7199); //10Khz的计数频率，计数到2000为2s while(1);&#125; 2. 库函数版(1). timer.c：首先对定时器 2 进行时钟使能，然后设置自动重装载值和预分频值， 将 TIM2 设置为向下计数模式，配置好中断优先级后使能 TIM2 中断，最后开始中断服务函数，执行跑马灯程序，执行完毕后清除中断标志位，以便下次中断的正常进行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//通用定时器中断初始化//这里时钟选择为APB1的2倍，而APB1为36M//arr：自动重装值。//psc：时钟预分频数//这里使用的是定时器2!unsigned int count = 0;void TIM2_Int_Init(u16 arr,u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); //时钟使能 TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值 计数到20000为2000ms TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值 10Khz的计数频率 TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Down; //TIM向下计数模式 TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位 TIM_ITConfig( //使能或者失能指定的TIM中断 TIM2, //TIM2 TIM_IT_Update , ENABLE //使能 ); NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; //TIM2中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4; //抢占优先级4级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; //响应优先级1级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 TIM_Cmd(TIM2, ENABLE); //使能TIMx外设 &#125;//TIM2中断服务函数void TIM2_IRQHandler(void)&#123; if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET) //检查指定的TIM中断发生与否:TIM 中断源 &#123; if(count==0)&#123; LED0 = 0; LED1 = 1; LED2 = 1; LED3 = 1; count+=1; &#125;else if(count==1)&#123; LED0 = 1; LED1 = 0; LED2 = 1; LED3 = 1; count+=1; &#125;else if(count==2)&#123; LED0 = 1; LED1 = 1; LED2 = 0; LED3 = 1; count+=1; &#125;else if(count==3)&#123; LED0 = 1; LED1 = 1; LED2 = 1; LED3 = 0; count = 0; &#125; TIM_ClearITPendingBit(TIM2, TIM_IT_Update ); //清除TIM2的中断待处理位:TIM 中断源 &#125;&#125; (2). main.c：在主函数中设置中断优先级分组为组 3。加入时钟 2 中断初始化函数 TIM2_Int_Init(19999,7199)。（其余解释与寄存器版主函数相同） 12345678int main(void)&#123; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3); //设置中断优先级分组3 LED_Init(); //初始化与LED连接的硬件接口 TIM2_Int_Init(19999,7199); //10Khz的计数频率，计数到20000为2000ms while(1);&#125; 3. 参考资料定时器中断实验原码下载： 网盘下载：定时器中断实验.zip 密码：8jsp 内容包含： 寄存器和库函数模板初始原码 按实验要求修改后的原码 嵌入式STM32学习视频： 字母站传送门：【正点原子】STM32开发板实验教程 所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途想看更多有关【嵌入式STM32】的文章可以前往：【嵌入式STM32】文章汇总","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"嵌入式/STM32","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://franxhao.top/tags/STM32/"}]},{"title":"【嵌入式STM32】（五）外部中断实验","slug":"STM32-5-waibuzhongduan","date":"2021-05-20T03:11:38.000Z","updated":"2021-06-15T10:55:06.604Z","comments":true,"path":"undefined/5817d212.html","link":"","permalink":"https://franxhao.top/undefined/5817d212.html","excerpt":"0. 实验要求掌握寄存器版和库函数版的外部中断实验 本次实验以按键亮灯为基础，按键接端口 PC0-PC3，LED灯接端口 PC8-PC11。中断优先级分组组 2，抢占优先级 2 级，响应优先级分别为 3102 （注：文章仅贴出修改部分代码，详细原码请下载资料包查看）","text":"0. 实验要求掌握寄存器版和库函数版的外部中断实验 本次实验以按键亮灯为基础，按键接端口 PC0-PC3，LED灯接端口 PC8-PC11。中断优先级分组组 2，抢占优先级 2 级，响应优先级分别为 3102 （注：文章仅贴出修改部分代码，详细原码请下载资料包查看） 1. 寄存器版exit.c：设置外部中断服务，初始化外部中断程序，PC0-PC3 为中断输入，中 断优先级分组为组 2，抢占优先级 2 级，响应优先级 3102 1234567891011121314151617181920212223242526272829303132333435363738394041424344//外部中断0服务程序void EXTI0_IRQHandler(void)&#123; delay_ms(10); //消抖 LED0=!LED0; EXTI-&gt;PR=1&lt;&lt;0; //清除LINE0上的中断标志位 &#125;//外部中断1服务程序void EXTI1_IRQHandler(void)&#123; delay_ms(10); //消抖 LED1=!LED1; EXTI-&gt;PR=1&lt;&lt;1; //清除LINE1上的中断标志位 &#125;//外部中断2服务程序void EXTI2_IRQHandler(void)&#123; delay_ms(10); //消抖 LED2=!LED2; EXTI-&gt;PR=1&lt;&lt;2; //清除LINE2上的中断标志位 &#125;//外部中断3服务程序void EXTI3_IRQHandler(void)&#123; delay_ms(10); //消抖 LED3=!LED3; EXTI-&gt;PR=1&lt;&lt;3; //清除LINE3上的中断标志位 &#125;//外部中断初始化程序//初始化PC0-PC3为中断输入.void EXTI_Init(void)&#123; KEY_Init(); Ex_NVIC_Config(GPIO_C,0,FTIR); //下降沿触发 Ex_NVIC_Config(GPIO_C,1,FTIR); //下降沿触发 Ex_NVIC_Config(GPIO_C,2,FTIR); //下降沿触发 Ex_NVIC_Config(GPIO_C,3,FTIR); //下降沿触发 MY_NVIC_Init(2,3,EXTI0_IRQn,2); //抢占2，子优先级3，组2 MY_NVIC_Init(2,1,EXTI1_IRQn,2); //抢占2，子优先级1，组2 MY_NVIC_Init(2,0,EXTI2_IRQn,2); //抢占2，子优先级0，组2 MY_NVIC_Init(2,2,EXTI3_IRQn,2); //抢占2，子优先级2，组2 &#125; 2. 库函数版exti.c：外部中断初始化函数。使能 AFIO 时钟，设置中断模式且下降沿触发， 根据 EXTI_InitStruct 中指定的参数初始化外设 EXTI 寄存器；使能按键所在 的外部中断通道，抢占优先级 2 级、响应优先级 3102，开启使能后根据 NVIC_InitStruct 中指定的参数初始化外设 NVIC 寄存器。最后开启外部中断 服务，服务最后清除 EXTI*线路挂起位。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//外部中断初始化函数void EXTIX_Init(void)&#123; EXTI_InitTypeDef EXTI_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); //外部中断，需要使能AFIO时钟 KEY_Init();//初始化按键对应io模式 //GPIOC.0 中断线以及中断初始化配置 GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource0); EXTI_InitStructure.EXTI_Line = EXTI_Line0; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;//下降沿触发 EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 //GPIOC.1 中断线以及中断初始化配置 GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource1); EXTI_InitStructure.EXTI_Line = EXTI_Line1; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;//下降沿触发 EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 //GPIOC.2 中断线以及中断初始化配置 GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource2); EXTI_InitStructure.EXTI_Line = EXTI_Line2; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;//下降沿触发 EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 //GPIOC.3 中断线以及中断初始化配置 GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource3); EXTI_InitStructure.EXTI_Line = EXTI_Line3; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;//下降沿触发 EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_InitStructure); //根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器 NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; //使能按键所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn; //使能按键所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01; //子优先级1 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn; //使能按键所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00; //子优先级0 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn; //使能按键所在的外部中断通道 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级2 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器&#125;void EXTI0_IRQHandler(void)&#123; delay_ms(10); //消抖 if(KEY0 == 0) &#123; LED0 = !LED0; &#125; EXTI_ClearITPendingBit(EXTI_Line0); //清除EXTI0线路挂起位&#125;void EXTI1_IRQHandler(void)&#123; delay_ms(10); //消抖 if(KEY1 == 0) &#123; LED1 = !LED1; &#125; EXTI_ClearITPendingBit(EXTI_Line1); //清除EXTI1线路挂起位&#125;void EXTI2_IRQHandler(void)&#123; delay_ms(10); //消抖 if(KEY2 == 0) &#123; LED2 = !LED2; &#125; EXTI_ClearITPendingBit(EXTI_Line2); //清除EXTI2线路挂起位&#125;void EXTI3_IRQHandler(void)&#123; delay_ms(10); //消抖 if(KEY3 == 0) &#123; LED3 = !LED3; &#125; EXTI_ClearITPendingBit(EXTI_Line3); //清除EXTI3线路挂起位&#125; main函数中添加 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 来设置中断优先级分组为组2 3. 参考资料外部中断实验原码下载： 网盘下载：外部中断实验.zip 密码：ac9y 内容包含： 寄存器和库函数模板初始原码 按实验要求修改后的原码 嵌入式STM32学习视频： 字母站传送门：【正点原子】STM32开发板实验教程 所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途想看更多有关【嵌入式STM32】的文章可以前往：【嵌入式STM32】文章汇总","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"嵌入式/STM32","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://franxhao.top/tags/STM32/"}]},{"title":"【嵌入式STM32】（四）串口实验","slug":"STM32-4-chuankou","date":"2021-05-15T01:58:00.000Z","updated":"2021-06-14T03:02:49.768Z","comments":true,"path":"undefined/d0886a84.html","link":"","permalink":"https://franxhao.top/undefined/d0886a84.html","excerpt":"0. 实验要求掌握寄存器版和库函数版的串口实验 使用寄存器和库函数模板分别做串口1通信和串口5通信实验，其中寄存器和库函数要求如下： 寄存器要求：波特率为 115200，设置1位停止位、1位奇数校验位，开启接受中断。发送端推挽复用输出，速度为 10MHz，接收端浮空输入。使用串口助手调试，并能够对代码进行解释，理解中断服务逻辑 库函数要求：波特率为 115200，设置 0.5 位停止位、1位偶数校验位，开启接受中断。发送端推挽复用输出，速度 10MHz；接收端下拉输入。中断优先级组 3，抢占优先级 2 级，响应优先级 1 级","text":"0. 实验要求掌握寄存器版和库函数版的串口实验 使用寄存器和库函数模板分别做串口1通信和串口5通信实验，其中寄存器和库函数要求如下： 寄存器要求：波特率为 115200，设置1位停止位、1位奇数校验位，开启接受中断。发送端推挽复用输出，速度为 10MHz，接收端浮空输入。使用串口助手调试，并能够对代码进行解释，理解中断服务逻辑 库函数要求：波特率为 115200，设置 0.5 位停止位、1位偶数校验位，开启接受中断。发送端推挽复用输出，速度 10MHz；接收端下拉输入。中断优先级组 3，抢占优先级 2 级，响应优先级 1 级 0.1 前期准备 串口 1 对应串口时钟 RCC 是 APB2ENR，串口 2-5 对应串口时钟 RCC 是 APB1ENR 串口 1→pclk2（72M）、串口 2-5 →pclk1（36M） 串口 1 接收端（RXD）→PA10、发送端（TXD）→PA9 串口 5 接收端（RXD）→PD2、发送端（TXD）→PC12 在寄存器配置中，停止位(STOP bits)需要用到 USART_CR2 寄存器。CR2寄存器中使用位13:12这2位来设置停止位的位数，根据参考手册停止位设置如下： 00：1个停止位 01：0.5个停止位 10：2个停止位 11：1.5个停止位 注：UART4和UART5不能用0.5停止位和1.5停止位 1. 串口1通信1.1 寄存器版(1). usart.h： 12345678#define USART_REC_LEN 200 //定义最大接收字节数 200#define EN_USART1_RX 1 //使能（1）/禁止（0）串口1接收//接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 extern u8 USART_RX_BUF[USART_REC_LEN];extern u16 USART_RX_STA; //接收状态标记 //如果想串口中断接收，请不要注释以下宏定义void uart_init(u32 pclk2,u32 bound); (2). usart.c：修改 IO 口使能时钟和功能参数（仅展示修改部分代码，详细原码请下载资料包查看） 1234567891011121314151617181920212223242526272829303132//PA9-PA10 串口1//初始化IO//pclk2:PCLK2时钟频率(72Mhz)//bound:波特率 void uart_init(u32 pclk2,u32 bound)&#123; float temp; u16 mantissa; u16 fraction; temp=(float)(pclk2*1000000)/(bound*16);//得到USARTDIV mantissa=temp; //得到整数部分 fraction=(temp-mantissa)*16; //得到小数部分 mantissa&lt;&lt;=4; mantissa+=fraction; RCC-&gt;APB2ENR|=1&lt;&lt;2; //使能PORTA口时钟 RCC-&gt;APB2ENR|=1&lt;&lt;14; //使能串口时钟 GPIOA-&gt;CRH&amp;=0XFFFFF00F;//IO状态设置 10:0100--&gt;4 9:1001--&gt;9 GPIOA-&gt;CRH|=0X00000490;//IO状态设置 RCC-&gt;APB2RSTR|=1&lt;&lt;14; //复位串口1 RCC-&gt;APB2RSTR&amp;=~(1&lt;&lt;14);//停止复位 //波特率设置 USART1-&gt;BRR=mantissa; // 波特率设置 USART1-&gt;CR1|=0X360C; //校验位:1奇校验.数据位+1--&gt;9位 //360c--&gt;0011 0110 0000 1100 USART1-&gt;CR2|=0X0000; //1位停止 位13:12--&gt;00:1位停止 #if EN_USART1_RX //如果使能了接收 //使能接收中断 USART1-&gt;CR1|=1&lt;&lt;5; //接收缓冲区非空中断使能 MY_NVIC_Init(3,3,USART1_IRQn,2);//组2，最低优先级 #endif (3). main.c：主函数，串口 1→pclk2，速度 72MHz，所以 uart_init 中修改为 72，波特率 115200 12345678910111213141516171819202122232425262728293031323334353637int main(void)&#123; u8 t; u8 len; u16 times=0; Stm32_Clock_Init(9); //系统时钟设置 delay_init(72); //延时初始化 uart_init(72,115200); //串口初始化为115200 LED_Init(); //初始化与LED连接的硬件接口 while(1) &#123; if(USART_RX_STA&amp;0x8000) //1000 0000 0000 0000 &#123; //得到此次接收到的数据长度 0011 1111 1111 1111 bit13~0.接收到的有效字节数目 len=USART_RX_STA&amp;0x3fff; printf(\"\\r\\n您发送的消息为:\\r\\n\"); for(t=0;t&lt;len;t++) &#123; USART1-&gt;DR=USART_RX_BUF[t]; while((USART1-&gt;SR&amp;0X40)==0);//等待发送结束 &#125; printf(\"\\r\\n\\r\\n\");//插入换行 USART_RX_STA=0; &#125;else &#123; times++; if(times%5000==0) &#123; printf(\"\\r\\nALIENTEK MiniSTM32开发板 串口实验\\r\\n\"); printf(\"正点原子@ALIENTEK\\r\\n\\r\\n\\r\\n\"); &#125; if(times%200==0)printf(\"请输入数据,以回车键结束\\r\\n\"); if(times%30==0)LED0=!LED0;//闪烁LED,提示系统正在运行. delay_ms(10); &#125; &#125; &#125; 1.2 库函数版(1). usart.c：配置串口 1 和 GPIOA 使能时钟，以及配置功能参数；初始化串口设置，设置 9 位字长数据格式（加入校验位，数据位+1）、0.5 位停止位和偶校验位 Even；配置串口中断优先级，抢占优先级 2 级、相应优先级 1 级；最后 开启串口接受中断并使能串口 1（仅展示修改部分代码，详细原码请下载资料包查看） 1234567891011121314151617181920212223242526272829303132333435363738394041//串口初始化void uart_init(u32 bound)&#123; //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE); //使能USART1，GPIOA时钟 //USART1_TX GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz; //10MHz GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //推挽复用输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.9 //USART1_RX GPIOA.10初始化 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;//下拉输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.10 //Usart1 NVIC 配置 NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2 ;//抢占优先级2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; //子优先级1 (响应) NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(&amp;NVIC_InitStructure); //根据指定的参数初始化VIC寄存器 //USART 初始化设置 USART_InitStructure.USART_BaudRate = bound;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_9b;//字长为9位数据格式 加入1位校验位,数据位+1 USART_InitStructure.USART_StopBits = USART_StopBits_0_5;//0.5个停止位 USART_InitStructure.USART_Parity = USART_Parity_Even;//偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口1 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_Cmd(USART1, ENABLE); //使能串口1 &#125; (2). main.c：设置中断优先级分组 3，修改串口初始化波特率为 115200（仅展示修改部分代码，详细原码请下载资料包查看） 12345delay_init(); //延时函数初始化 // 设置中断优先级分组3NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);uart_init(115200); //串口初始化为115200LED_Init(); //初始化与LED连接的硬件接口 2. 串口5通信2.1 寄存器版(1). usart.h：头文件中自定义的函数将 USART 改为 UART，其对应的 usart.c 和 main.c 文件中对应的自定义函数名也要修改正确 12345678#define UART_REC_LEN 200 //定义最大接收字节数 200#define EN_UART5_RX 1 //使能（1）/禁止（0）串口1接收//接收缓冲,最大UART_REC_LEN个字节.末字节为换行符 extern u8 UART_RX_BUF[UART_REC_LEN]; extern u16 UART_RX_STA; //接收状态标记 //如果想串口中断接收，请不要注释以下宏定义void uart_init(u32 pclk1,u32 bound); (2). usart.c：修改对应的自定义函数，即 USART→UART；修改 IO 口和串口 5 的 使能时钟和功能参数，串口 5 对应 APB1ENR 和 APB1RSTR（仅展示修改部分代码，详细原码请下载资料包查看） 123456789101112131415161718192021222324252627282930313233343536373839//PD2-PC12 串口5//初始化IO//pclk1:PCLK1时钟频率(36Mhz)//bound:波特率 void uart_init(u32 pclk1,u32 bound)&#123; float temp; u16 mantissa; u16 fraction; temp=(float)(pclk1*1000000)/(bound*16);//得到USARTDIV mantissa=temp; //得到整数部分 fraction=(temp-mantissa)*16; //得到小数部分 mantissa&lt;&lt;=4; mantissa+=fraction; RCC-&gt;APB2ENR|=1&lt;&lt;5; //使能PORTD口时钟 RCC-&gt;APB2ENR|=1&lt;&lt;4; //使能PORTC口时钟 RCC-&gt;APB1ENR|=1&lt;&lt;20; //使能串口5时钟 GPIOD-&gt;CRL&amp;=0XFFFFF0FF;//IO状态设置 PD2:0100--&gt;4 接收端浮空输入 GPIOD-&gt;CRL|=0X00000400;//IO状态设置 GPIOC-&gt;CRH&amp;=0XFFF0FFFF;//IO状态设置 PC12:1001--&gt;9 发送端推挽复用，速度为10MHz GPIOC-&gt;CRH|=0X00090000;//IO状态设置 RCC-&gt;APB1RSTR|=1&lt;&lt;20; //复位串口5 RCC-&gt;APB1RSTR&amp;=~(1&lt;&lt;20);//停止复位 //波特率设置 UART5-&gt;BRR=mantissa; // 波特率设置 UART5-&gt;CR1|=0X360C; //校验位:1奇校验.数据位+1--&gt;9位 //360c--&gt;0011 0110 0000 1100 UART5-&gt;CR2|=0X0000; //1位停止 位13:12--&gt;00:1位停止 #if EN_UART5_RX //如果使能了接收 //使能接收中断 UART5-&gt;CR1|=1&lt;&lt;5; //接收缓冲区非空中断使能 MY_NVIC_Init(3,3,UART5_IRQn,2);//组2，最低优先级 #endif&#125; (3). main.c：串口 5→pclk1，对应速度 36MHz，所以 uart_init 中修改为 36，波特率 115200 123456789101112131415161718192021222324252627282930313233343536int main(void)&#123; u8 t; u8 len; u16 times=0; Stm32_Clock_Init(9); //系统时钟设置 delay_init(36); //延时初始化 uart_init(36,115200); //串口初始化为115200 LED_Init(); //初始化与LED连接的硬件接口 while(1) &#123; if(UART_RX_STA&amp;0x8000) &#123; len=UART_RX_STA&amp;0x3fff;//得到此次接收到的数据长度 printf(\"\\r\\n您发送的消息为:\\r\\n\"); for(t=0;t&lt;len;t++) &#123; UART5-&gt;DR=UART_RX_BUF[t]; while((UART5-&gt;SR&amp;0X40)==0);//等待发送结束 &#125; printf(\"\\r\\n\\r\\n\");//插入换行 UART_RX_STA=0; &#125;else &#123; times++; if(times%5000==0) &#123; printf(\"\\r\\nALIENTEK MiniSTM32开发板 串口实验\\r\\n\"); printf(\"正点原子@ALIENTEK\\r\\n\\r\\n\\r\\n\"); &#125; if(times%200==0)printf(\"请输入数据,以回车键结束\\r\\n\"); if(times%30==0)LED0=!LED0;//闪烁LED,提示系统正在运行. delay_ms(10); &#125; &#125; &#125; 2.2 库函数版(1). usart.c：配置串口 5 和 GPIOC、GPIOD 使能时钟，以及配置功能参数；初始化串口设置，设置 9 位字长数据格式（加入校验位，数据位+1）、0.5 位停止位和偶校验位 Even；配置串口中断优先级，抢占优先级 2 级、相应优先级 1 级；最后开启串口接受中断并使能串口 1。将自定义的 USART（USART1） 改为 UART（UART5）（仅展示修改部分代码，详细原码请下载资料包查看） 12345678910111213141516171819202122232425262728293031323334353637383940//串口初始化void uart_init(u32 bound)&#123; //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE); //使能UART5 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD, ENABLE); //GPIOC,GPIOD时钟 //UART5_TX GPIOC.12 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; //PC.12 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz; //10MHz GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //推挽复用输出 GPIO_Init(GPIOC, &amp;GPIO_InitStructure);//初始化GPIOC.12 //UART5_RX GPIOD.2初始化 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;//PD.2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;//下拉输入 GPIO_Init(GPIOD, &amp;GPIO_InitStructure);//初始化GPIOD.2 //UART5 NVIC 配置 NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2 ;//抢占优先级2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; //子优先级1 (响应) NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(&amp;NVIC_InitStructure); //根据指定的参数初始化VIC寄存器 //UART 初始化设置 USART_InitStructure.USART_BaudRate = bound;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_9b;//字长为9位数据格式 加入1位校验位,数据位+1 USART_InitStructure.USART_StopBits = USART_StopBits_0_5;//0.5个停止位 USART_InitStructure.USART_Parity = USART_Parity_Even;//偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式 USART_Init(UART5, &amp;USART_InitStructure); //初始化串口5 USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_Cmd(UART5, ENABLE); //使能串口5&#125; (2). main.c：设置中断优先级分组 3，修改串口初始化波特率为 115200（仅展示修改部分代码，详细原码请下载资料包查看） 1234delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3); //设置中断优先级分组3uart_init(115200); //串口初始化为115200LED_Init(); //初始化与LED连接的硬件接口 3. 参考资料串口实验原码下载： 网盘下载：串口实验.zip 密码：4mgf 内容包含： 寄存器和库函数模板初始原码 按实验要求修改后的原码 嵌入式STM32学习视频： 字母站传送门：【正点原子】STM32开发板实验教程 所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途想看更多有关【嵌入式STM32】的文章可以前往：【嵌入式STM32】文章汇总","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"嵌入式/STM32","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://franxhao.top/tags/STM32/"}]},{"title":"将网站迁移到Vercel托管","slug":"toVercel","date":"2021-05-10T02:56:38.000Z","updated":"2021-05-31T11:51:17.191Z","comments":true,"path":"undefined/86d73a10.html","link":"","permalink":"https://franxhao.top/undefined/86d73a10.html","excerpt":"前言关于Vercel首先，Vercel是免费的网站托管商，其中有许多大官网如Next.js,create-react-app,Nuxt.js等就是部署在部署托管在vercel的。同时Vercel操作简单友好，支持从github、gitlab的代码库中一键导入，支持自定义域名和SSL证书配置。访问速度也很可观，简直就是白嫖党的福音。","text":"前言关于Vercel首先，Vercel是免费的网站托管商，其中有许多大官网如Next.js,create-react-app,Nuxt.js等就是部署在部署托管在vercel的。同时Vercel操作简单友好，支持从github、gitlab的代码库中一键导入，支持自定义域名和SSL证书配置。访问速度也很可观，简直就是白嫖党的福音。 为什么取消了在coding上的托管原来本站是部署到coding上来托管的，但由于现在coding网站托管和腾讯云打通并且开始主推新版，旧版迟早是要被淘汰的（现在我在旧版coding托管的网站IP已经ping不到了），不得不迁移到腾讯云上。 CODING Pages 依托腾讯云资源提供相关静态托管能力，CODING 平台本身不收取任何费用。该产品使用了腾讯云对象存储 COS、内容分发网络 CDN、SSL 证书产品，其中 COS 和 CDN 采用用量计费模式，SSL 证书免费，所使用到的其他相关腾讯云产品本身亦会有一定的免费额度。 也就是迁移新版是需要收费的，个人网站费用不高，域名不是已经备案的网站的话，可以选择香港的服务器节点，但其实这新版很鸡肋。 迁移新版后国内访问速度再起不能？在设置好自定义域名后，网站在部署时会申请SSL证书，同时检验是否部署好COS实例，即使后面关闭了也会自动打开（尝试白嫖失败T^T），部署好后试着用域名去访问发现速度大大下跌，像校园网这种比较差的网络环境有时候根本打不开，查阅文章得知这是绕了地球一圈？好家伙，说好的香港节点呢(???￢_￢) 关于迁移新版速度可以参考这篇文章：CODING Pages 静态网站升级腾讯云新版踩坑小记 如何在Vercel上部署导入及部署 先成功部署Github Pages Vercel官网，登录/注册账号，关联Github账号，一键导入（这里以新用户注册讲解） 跟随向导，关联好Github帐号后可以寻找库中的代码，选择Only select repositories 指定库中项目（也可以选择ALL，建议选择需要的就可以了） Import一键导入，导入后即可自动部署成功 自定义域名部署成功后，进入项目，找到 Settings —&gt; Domains 。 添加后会提示重定向到哪个域名，也就是当输入 baidu.com 时会重定向到 www.baidu.com 的意思，当然反过来也可以，然后按要求配置好DNS的解析即可 最后Vercel的配置还是比较简单的，就是我的域名是在DNSPOD上解析的，所以没有配置vercel的NS会一直报配置不正确，但可以正常访问就可以了。 除了Vercel，还有一个免费的托管商 Netlify ，时间有限就不多折腾了，有兴趣的同学可以自行去查看。 补充（2021年5月31日更新）1、前期在vercel使用自定义域名部署的网站在国内已经无法访问了（亲测翻墙可以访问，不翻墙无法访问），经过辛苦查找各大网站，终于在知乎一篇文章的评论下发现了有用的信息： 官方已经对此问题响应，把A记录改成76.223.126.88，或把CNAME改成cname-china.vercel-dns.com （至于响应在哪个位置待我有时间去找找，知道的同学可以通过Email提示一下）注意：这两项修改均是在vercel的DNS解析中修改，且默认记录是无法修改的，直接Add就行。 2、使用vercel出现的DNS解析的问题，建议暂停在DNSPOD解析，直接在域名商解析，这样就不会出现配置报错问题了，同时也是为了避免服务器找不到的问题。 本文参考：如何将 github pages 迁移到 vercel 上托管有关 Netlify 的部署可参考：如何将网站代码部署到 netlify 上免费托管","categories":[{"name":"博客","slug":"博客","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"博客/Hexo","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://franxhao.top/tags/Hexo/"}]},{"title":"【嵌入式STM32】（三）按键亮灯实验","slug":"STM32-3-anjian","date":"2021-04-18T14:09:36.000Z","updated":"2021-06-14T02:54:53.108Z","comments":true,"path":"undefined/44c24675.html","link":"","permalink":"https://franxhao.top/undefined/44c24675.html","excerpt":"0. 实验要求掌握寄存器和库函数两个版本的按键亮灯实验 LED灯接端口 PC8—PC11，按键接端口 PC0—PC3，全部设置成上拉模式，实现： 一个按键控制一个灯 一个按键控制两个灯","text":"0. 实验要求掌握寄存器和库函数两个版本的按键亮灯实验 LED灯接端口 PC8—PC11，按键接端口 PC0—PC3，全部设置成上拉模式，实现： 一个按键控制一个灯 一个按键控制两个灯 1. 一个按键控制一个灯1.1 寄存器版(1). key.h：配置 4 个按键状态，初始化 IO 123456789101112#define KEY0_PRES 1 //KEY0按下#define KEY1_PRES 2 //KEY1按下#define KEY2_PRES 3 //KEY1按下#define KEY3_PRES 4 //KEY1按下#define KEY0 PCin(0) //PC0#define KEY1 PCin(1) //PC1#define KEY2 PCin(2) //PC2 #define KEY3 PCin(3) //PC3 void KEY_Init(void); //IO初始化u8 KEY_Scan(u8 mode); //按键扫描函数 (2). key.c： 使能 PORTC 时钟，设置按键 PC0—PC3 的 CNF 为上拉模式，MODE 为输入模式。根据参考手册可知，CNF:上/下拉模式 –&gt; 10，MODE:输入模式 –&gt; 00，所以1000 –&gt; 8 1234567891011121314151617181920212223242526//按键初始化函数 //PC0和PC3 设置成输入void KEY_Init(void)&#123; RCC-&gt;APB2ENR|=1&lt;&lt;4; //使能PORTC时钟 JTAG_Set(SWD_ENABLE); //关闭JTAG,开启SWD GPIOC-&gt;CRL&amp;=0XFFFFFFF0; //PC0设置成输入 // 1000 -&gt; 8 CNF:上/下拉模式 -&gt; 10;MODE:输入模式 -&gt; 00 GPIOC-&gt;CRL|=0X00000008; GPIOC-&gt;ODR|=1&lt;&lt;0; //PC0上拉 //PC1设置成输入。ODR寄存器默认为0即下拉，不用设置PA0下拉 GPIOC-&gt;CRL&amp;=0XFFFFFF0F; GPIOC-&gt;CRL|=0X00000080; GPIOC-&gt;ODR|=1&lt;&lt;1; //PC1上拉 GPIOC-&gt;CRL&amp;=0XFFFFF0FF; //PC2设置成输入 GPIOC-&gt;CRL|=0X00000800; GPIOC-&gt;ODR|=1&lt;&lt;2; //PC2上拉 GPIOC-&gt;CRL&amp;=0XFFFF0FFF; //PC3设置成输入 GPIOC-&gt;CRL|=0X00008000; GPIOC-&gt;ODR|=1&lt;&lt;3; //PC3上拉 &#125; 按键处理函数 u8 KEY_Scan(u8 mode)，mode:0,不支持连续按;1, 支持连续按; 返回值：0，表示没有任何按键按下，KEY0_PRES，KEY0 按下， 其余按键也是如此 12345678910111213141516//按键处理(扫描)函数u8 KEY_Scan(u8 mode)&#123; static u8 key_up=1;//按键按松开标志 if(mode)key_up=1; //支持连按 if(key_up&amp;&amp;(KEY0==0||KEY1==0||KEY2==0||KEY3==0)) &#123; delay_ms(10);//去抖动 key_up=0; if(KEY0==0)return KEY0_PRES; else if(KEY1==0)return KEY1_PRES; else if(KEY2==0)return KEY2_PRES; else if(KEY3==0)return KEY3_PRES; &#125;else if(KEY0==1&amp;&amp;KEY1==1&amp;&amp;KEY2==1&amp;&amp;KEY3==1)key_up=1; return 0;// 无按键按下&#125; (3). led.h：LED 端口定义及初始化 1234567//LED端口定义#define LED0 PCout(8) // PC8#define LED1 PCout(9) // PC9 #define LED2 PCout(10) // PC10#define LED3 PCout(11) // PC11void LED_Init(void); //初始化 (4). led.c：LED IO初始化 123456789101112//初始化PC8-PC11为输出口.并使能时钟 void LED_Init(void)&#123; RCC-&gt;APB2ENR|=1&lt;&lt;4; //使能PORTC时钟 GPIOC-&gt;CRH&amp;=0XFFFF0000; GPIOC-&gt;CRH|=0X00003333;//PC8-PC11 推挽输出 GPIOC-&gt;ODR|=1&lt;&lt;8; //PC8 输出高 GPIOC-&gt;ODR|=1&lt;&lt;9; //PC9输出高 GPIOC-&gt;ODR|=1&lt;&lt;10; //PC10输出高 GPIOC-&gt;ODR|=1&lt;&lt;11; //PC11输出高 &#125; (5). main.c：主函数。设置循环判断按键状态的返回值 12345678910111213141516171819202122232425262728293031int main(void)&#123; vu8 t; Stm32_Clock_Init(9); //系统时钟设置 delay_init(72); //延时初始化 LED_Init(); //初始化与LED连接的硬件接口 KEY_Init(); //初始化与按键连接的硬件接口 LED0=1; //LED初始状态 while(1) &#123; t=KEY_Scan(0); //得到键值 switch(t) &#123; case KEY0_PRES: LED0=!LED0; break; case KEY1_PRES: LED1=!LED1; break; case KEY2_PRES: LED2=!LED2; break; case KEY3_PRES: LED3=!LED3; break; default: delay_ms(10); &#125; &#125; &#125; 1.2 库函数版(1). key.h：配置 4 个按键状态，初始化 IO 123456789101112#define KEY0 GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_0)//读取按键0#define KEY1 GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_1)//读取按键1#define KEY2 GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_2)//读取按键2 #define KEY3 GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_3)//读取按键3#define KEY0_PRES 1 //KEY0 #define KEY1_PRES 2 //KEY1 #define KEY2_PRES 3 //KEY2#define KEY3_PRES 4 //KEY3void KEY_Init(void); //IO初始化u8 KEY_Scan(u8 mode); //按键扫描函数 (2). key.c： 使能 PORTC 时钟，设置按键 PC0—PC3 为上拉模式，初始化 GPIOC 1234567891011121314151617181920212223242526272829//按键初始化函数 //PC0-PC3 设置成输入void KEY_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; //使能PORTC时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); //关闭JTAG，使能SWD，可以用SWD模式调试 GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;//PC0 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//设置成上拉输入 GPIO_Init(GPIOC, &amp;GPIO_InitStructure);//初始化GPIOC0 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;//PC1 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//设置成上拉输入 GPIO_Init(GPIOC, &amp;GPIO_InitStructure);//初始化GPIOC1 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;//PC2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //设置成上拉输入 GPIO_Init(GPIOC, &amp;GPIO_InitStructure);//初始化GPIOC2 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//PC3 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//设置成上拉输入 GPIO_Init(GPIOC, &amp;GPIO_InitStructure);//初始化GPIOC3 &#125; 按键处理函数 u8 KEY_Scan(u8 mode)，mode:0, 不支持连续按;1,支持连续按; 返回值：0，表示没有任何按键按下， KEY0_PRES，KEY0 按下，其余按键也是如此 123456789101112131415u8 KEY_Scan(u8 mode)&#123; static u8 key_up=1;//按键按松开标志 if(mode)key_up=1; //支持连按 if(key_up&amp;&amp;(KEY0==0||KEY1==0||KEY2==0||KEY3==0)) &#123; delay_ms(10);//去抖动 key_up=0; if(KEY0==0)return KEY0_PRES; else if(KEY1==0)return KEY1_PRES; else if(KEY2==0)return KEY2_PRES; else if(KEY3==0)return KEY3_PRES; &#125;else if(KEY0==1&amp;&amp;KEY1==1&amp;&amp;KEY2==1&amp;&amp;KEY3==1)key_up=1; return 0;// 无按键按下&#125; (3). led.h：LED 端口定义及初始化 123456#define LED0 PCout(8) // PC8#define LED1 PCout(9) // PC9#define LED2 PCout(10) // PC10#define LED3 PCout(11) // PC11void LED_Init(void);//初始化 (4). led.c：初始化 PC8—PC11 为输出口.并使能 PORTC 时钟，初始化 LED IO 1234567891011121314151617181920212223242526272829303132//初始化PC8-PC11为输出口.并使能时钟 //LED IO初始化void LED_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);//使能PC端口时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;//LED0--&gt;PC8 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//IO口速度为50MHz GPIO_Init(GPIOC, &amp;GPIO_InitStructure); //根据设定参数初始化GPIOC.8 GPIO_SetBits(GPIOC,GPIO_Pin_8);//PC8 输出高 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;//LED1--&gt;PC9 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//IO口速度为50MHz GPIO_Init(GPIOC, &amp;GPIO_InitStructure);//根据设定参数初始化GPIOC.9 GPIO_SetBits(GPIOC,GPIO_Pin_9);//PC9 输出高 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//LED2--&gt;PC10 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//IO口速度为50MHz GPIO_Init(GPIOC, &amp;GPIO_InitStructure);//根据设定参数初始化GPIOC.10 GPIO_SetBits(GPIOC,GPIO_Pin_10);//PC10 输出高 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;//LED3--&gt;PC11 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//IO口速度为50MHz GPIO_Init(GPIOC, &amp;GPIO_InitStructure);//根据设定参数初始化GPIOC.11 GPIO_SetBits(GPIOC,GPIO_Pin_11);//PC11 输出高&#125; (5). main.c：主函数 1234567891011121314151617181920212223242526272829int main(void) &#123; u8 t=0; delay_init(); //延时函数初始化 LED_Init(); //初始化与LED连接的硬件接口 KEY_Init(); //初始化与按键连接的硬件接口 LED0=0; //初始化LED while(1) &#123; t=KEY_Scan(0); //得到键值 switch(t) &#123; case KEY0_PRES: LED0=!LED0; break; case KEY1_PRES: LED1=!LED1; break; case KEY2_PRES: LED2=!LED2; break; case KEY3_PRES: LED3=!LED3; break; default: delay_ms(10); &#125; &#125;&#125; 2. 一个按键控制两个灯例如按下按键1，LED 1,3亮；按键2，LED 2,4亮；按键3，LED 1,2亮；按键4，LED 3,4亮 对于这个实验，只需要修改 一个按键控制一个灯 的主函数就可以实现，所以按键实验主要以学好上面的实验为主 2.1 寄存器和库函数的主函数相同main.c：主函数。为避免控制两个灯时出现问题，需要给所有的LED灯设置一下初值 123456789101112131415161718192021222324252627282930313233343536373839int main(void)&#123; vu8 t; Stm32_Clock_Init(9); //系统时钟设置 delay_init(72); //延时初始化 LED_Init(); //初始化与LED连接的硬件接口 KEY_Init(); //初始化与按键连接的硬件接口 //给4个LED灯设置初值 LED0=1; LED1=1; LED2=1; LED3=1; while(1) &#123; t=KEY_Scan(0); //得到键值 switch(t) &#123; case KEY0_PRES: LED0=!LED0; LED2=!LED2; break; case KEY1_PRES: LED1=!LED1; LED3=!LED3; break; case KEY2_PRES: LED0=!LED0; LED1=!LED1; break; case KEY3_PRES: LED3=!LED3; LED2=!LED2; break; default: delay_ms(10); &#125; &#125; &#125; 3. 参考资料按键实验源码下载： 网盘下载：按键亮灯实验.zip 密码：edu5 内容包含： 寄存器和库函数模板初始原码 按实验要求修改后的原码 嵌入式STM32学习视频： 字母站传送门：【正点原子】STM32开发板实验教程 所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途想看更多有关【嵌入式STM32】的文章可以前往：【嵌入式STM32】文章汇总","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"嵌入式/STM32","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://franxhao.top/tags/STM32/"}]},{"title":"【嵌入式STM32】（二）跑马灯实验","slug":"STM32-2-paoma","date":"2021-04-10T13:06:25.000Z","updated":"2021-06-14T02:50:39.517Z","comments":true,"path":"undefined/35ffacf0.html","link":"","permalink":"https://franxhao.top/undefined/35ffacf0.html","excerpt":"实验要求使用PA8和PD2端口，用寄存器和库函数两个模板实现","text":"实验要求使用PA8和PD2端口，用寄存器和库函数两个模板实现 寄存器版led.h： 12345//LED端口定义#define LED0 PAout(8) // PA8#define LED1 PDout(2) // PD2 void LED_Init(void); //初始化 led.c： 1234567891011121314//初始化PA8和PD2为输出口.并使能这两个口的时钟//LED IO初始化void LED_Init(void)&#123; RCC-&gt;APB2ENR|=1&lt;&lt;2; //使能PORTA时钟 RCC-&gt;APB2ENR|=1&lt;&lt;5; //使能PORTD时钟 GPIOA-&gt;CRH&amp;=0XFFFFFFF0; GPIOA-&gt;CRH|=0X00000003; //PA8 推挽输出 GPIOA-&gt;ODR|=1&lt;&lt;8; //PA8 输出高 GPIOD-&gt;CRL&amp;=0XFFFFF0FF; GPIOD-&gt;CRL|=0X00000300;//PD.2推挽输出 GPIOD-&gt;ODR|=1&lt;&lt;2; //PD.2输出高&#125; main.c： 123456789101112131415int main(void)&#123; Stm32_Clock_Init(9); //系统时钟设置 delay_init(72); //延时初始化 LED_Init(); //初始化与LED连接的硬件接口 while(1) &#123; LED0=0; LED1=1; delay_ms(300); LED0=1; LED1=0; delay_ms(300); &#125; &#125; 库函数版led.h： 1234#define LED0 PAout(8) // PA8#define LED1 PDout(2) // PD2 void LED_Init(void);//初始化 led.c： 12345678910111213141516171819//初始化PA8和PD2为输出口.并使能这两个口的时钟 //LED IO初始化void LED_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; //使能PA,PD端口时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOD, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; //LED0--&gt;PA.8 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//IO口速度为50MHz GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //根据设定参数初始化GPIOA.8 GPIO_SetBits(GPIOA,GPIO_Pin_8); //PA.8 输出高 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;//LED1--&gt;PD.2 端口配置, 推挽输出 GPIO_Init(GPIOD, &amp;GPIO_InitStructure);//推挽输出 ，IO口速度为50MHz GPIO_SetBits(GPIOD,GPIO_Pin_2); //PD.2 输出高 &#125; main.c： 1234567891011121314int main(void) &#123; delay_init(); //延时函数初始化 LED_Init(); //初始化与LED连接的硬件接口 while(1) &#123; LED0=0; LED1=1; delay_ms(300); //延时300ms LED0=1; LED1=0; delay_ms(300); //延时300ms &#125; &#125; 思考题修改代码，用库函数模板实现战舰版跑马灯 其中 PA8 和 PD2 改为 PE5 和 PB5、开漏输出、10MHz 代码敬请期待~ ~ ~ 参考资料跑马灯实验源码下载： 网盘下载：跑马灯实验（含寄存器和库函数）.zip 密码：8k6g 嵌入式STM32学习视频： 字母站传送门：【正点原子】STM32开发板实验教程 所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途想看更多有关【嵌入式STM32】的文章可以前往：【嵌入式STM32】文章汇总","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"嵌入式/STM32","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://franxhao.top/tags/STM32/"}]},{"title":"【嵌入式STM32】（一）新建库函数版和寄存器版工程模板","slug":"STM32-1-NewProject","date":"2021-03-26T16:20:59.000Z","updated":"2021-06-12T23:04:52.368Z","comments":true,"path":"undefined/fc8a844.html","link":"","permalink":"https://franxhao.top/undefined/fc8a844.html","excerpt":"前言开个新坑，STM32的相关文章是作者大三第二学期学习嵌入式这门课程的相关记录和总结。理论部分我们主要学习 STM32F103ZET6 和 STM32F103RCT6；而实验部分使用的是 STM32F103VCT6。不用担心，它们在学习上差别不是很大。 新建库函数版和寄存器版工程模板在做实验前，当然是要先建好工程模板才能进行下一项操作啦，STM32的开篇文章就以新建工程模板开始。","text":"前言开个新坑，STM32的相关文章是作者大三第二学期学习嵌入式这门课程的相关记录和总结。理论部分我们主要学习 STM32F103ZET6 和 STM32F103RCT6；而实验部分使用的是 STM32F103VCT6。不用担心，它们在学习上差别不是很大。 新建库函数版和寄存器版工程模板在做实验前，当然是要先建好工程模板才能进行下一项操作啦，STM32的开篇文章就以新建工程模板开始。 首先STM32的代码分为寄存器版本和库函数版本，实验环境是 Keil 5 和 MDK5。这次笔记记录在幕布中，分享链接如下： STM32新建工程模板笔记：幕布传送门：文档链接: https://share.mubu.com/doc/3_-lVqCPlu3 密码: lzh9相关文件：包含寄存器和库函数的模板STM32F10x_StdPeriph_Lib_V3.5.0 文件分享链接：网盘下载: 新建工程模板.zip 密码:3fg5嵌入式STM32学习视频：字母站传送门：【正点原子】STM32开发板实验教程 关于笔记的说明其实博客的文章更多是总结出笔记的终稿，然后再将它们上传，需要一定的时间去撰写。而在日常中，除了手写做笔记，我还使用幕布，幕布是一款思维导图软件，风格简约。在记录笔记时使用的是大纲模式，分层要更加明显，可以从大纲模式转为思维导图模式，同时还可以生成链接分享自己的笔记，是一款不错的笔记软件。所以我在幕布上有相关文章的笔记的话会附上分享链接，通过看大纲或思维导图更直观地进行学习。 所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途想看更多有关【嵌入式STM32】的文章可以前往：【嵌入式STM32】文章汇总","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"嵌入式/STM32","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://franxhao.top/tags/STM32/"}]},{"title":"【C51单片机】（五）数码管动态显示 00—20","slug":"单片机-作业5","date":"2021-03-16T01:29:57.000Z","updated":"2021-06-12T13:04:54.877Z","comments":true,"path":"undefined/fc63a592.html","link":"","permalink":"https://franxhao.top/undefined/fc63a592.html","excerpt":"实验题目使用共阴极数码管动态显示 00—20，要求 P1.0—P1.7 接 a—dp，P2.0 接1，P2.1 接2。 动态显示和静态显示静态显示就是每一个数码管的段码都要独占具有锁存功能的输出口, CPU把要显示的字码送到输出口上,就可以使数码管显示对应的字符, 直到下一次送出另外一个字码之前, 显示的内容一直不会消失","text":"实验题目使用共阴极数码管动态显示 00—20，要求 P1.0—P1.7 接 a—dp，P2.0 接1，P2.1 接2。 动态显示和静态显示静态显示就是每一个数码管的段码都要独占具有锁存功能的输出口, CPU把要显示的字码送到输出口上,就可以使数码管显示对应的字符, 直到下一次送出另外一个字码之前, 显示的内容一直不会消失 动态显示就是把所有显示器的8个段码中的A-dp的各个相同段连接在一起, 接到一个公共的输出口上,而数码管的位端分别接在另外的输出口上,通过这两个输出口的两组信号相互作用来产生显示效果。即让各位数码管按照一定顺序轮流显示, 只要扫描频率足够高, 由于人眼的“ 视觉暂留”现象,就能连续稳定的显示 静态显示优点：显示稳定、亮度大, 节约CPU时间, 但占有I/O口线较多, 硬件成本高。动态显示优点：其特点在于能显著降低显示部分成本,大大减少显示接口的连线结构。举例, 静态驱动4位数码管, 需要4×8=32个I/O口, 而动态的驱动位数码管只需要4+8=12个I/O口。 代码实现12345678910111213141516171819202122232425262728293031#include&lt;reg51.h&gt;unsigned char code table[10]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;unsigned char n;void delay(unsigned int time)&#123; unsigned i,j; for(i=0;i&lt;time;i++) for(j=0;j&lt;100;j++) ;&#125;void main()&#123; while(1) &#123; for(n=0;n&lt;21;n++) &#123; P1=table[n/10]; P2=0xfe; delay(300); P2=0xff; P1=table[n%10]; P2=0xfd; delay(300); P2=0xff; &#125; P1=0x00; &#125;&#125; 调整延时函数 delay() 可以控制显示速度的快慢 仿真演示","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C51单片机","slug":"嵌入式/C51单片机","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/C51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"C51单片机","slug":"C51单片机","permalink":"https://franxhao.top/tags/C51%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"【C51单片机】（四）按钮控制数码管显示00<==>20体验","slug":"单片机-作业4","date":"2021-03-13T12:50:25.000Z","updated":"2021-06-12T13:04:49.562Z","comments":true,"path":"undefined/82b44f.html","link":"","permalink":"https://franxhao.top/undefined/82b44f.html","excerpt":"实验题目P1和P1接两个共阴极的数码管，P3.2接一个按钮，P3.3接一个按钮。 按下3.3，2个数码管从00显示到20；按下3.3，2个数码管从20减到00 3.2闭合，3.3断开，00-20；3.3断开，3.2闭合，20-00","text":"实验题目P1和P1接两个共阴极的数码管，P3.2接一个按钮，P3.3接一个按钮。 按下3.3，2个数码管从00显示到20；按下3.3，2个数码管从20减到00 3.2闭合，3.3断开，00-20；3.3断开，3.2闭合，20-00 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;reg51.h&gt;//定义共阴极数值表unsigned char code dofly_table[10]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;unsigned char c;void delay(unsigned int time)&#123; unsigned i,j; for(i=0;i&lt;time;i++) for(j=0;j&lt;1000;j++) ;&#125;void main()&#123; //开启时，数码管显示00 P1=0x3f; P2=0x3f; while(1) &#123; if(P3==0xfb) //按下P3.2 &#123; for(c=0;c&lt;20;c++) &#123; P1=dofly_table[c/10]; P2=dofly_table[c%10]; delay(30); &#125; &#125; else if(P3==0xf7) //按下P3.3 &#123; for(c=20;c&gt;0;c--) &#123; P1=dofly_table[c/10]; P2=dofly_table[c%10]; delay(30); &#125; &#125; else P1=dofly_table[c/10]; P2=dofly_table[c%10]; &#125; &#125; 仿真演示 小结本次实验需要熟悉共阴极数码管的数值表，以及P3.2、P3.3口的十六进制表示方法，用来实现按钮的控制。 关于P3口：P3.0 ==&gt; 0xfe ==&gt;1111 1110P3.1 ==&gt; 0xfd ==&gt;1111 1101P3.2 ==&gt; 0xfb ==&gt;1111 1011P3.3 ==&gt; 0xf7 ==&gt;1111 0111……关于共阴极数码管的数值表可以参考 单片机-作业3 小结","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C51单片机","slug":"嵌入式/C51单片机","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/C51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"C51单片机","slug":"C51单片机","permalink":"https://franxhao.top/tags/C51%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"【C51单片机】（三）共阳极LED数码管实现0-9显示","slug":"单片机-作业3","date":"2021-03-13T06:48:04.000Z","updated":"2021-06-12T13:04:41.112Z","comments":true,"path":"undefined/acec2d97.html","link":"","permalink":"https://franxhao.top/undefined/acec2d97.html","excerpt":"实验题目P1接一个共阳极的LED数码管，实现显示 0 - 9","text":"实验题目P1接一个共阳极的LED数码管，实现显示 0 - 9 代码实现1234567891011121314151617181920212223#include&lt;reg51.h&gt; //包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义void delay(unsigned int time) //延时函数&#123; unsigned i,j; for(i=0;i&lt;time;i++) for(j=0;j&lt;1000;j++);&#125;void main()&#123; //共阳极数码管0-9显示数值表 unsigned char code dofly_table[10]=&#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90&#125;; unsigned char k; while(1) &#123; for(k=0;k&lt;10;k++) &#123; P1=dofly_table[k]; delay(40); &#125; &#125;&#125; 仿真演示 小结这次实验很简单，只要了解了数码管的数值表就可以通过简单的循环函数实现 0 - 9 的显示。 下面附上共阴极和共阳极数码管的数值表：","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C51单片机","slug":"嵌入式/C51单片机","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/C51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"C51单片机","slug":"C51单片机","permalink":"https://franxhao.top/tags/C51%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"自建frp内网穿透，实现非局域网远程windows","slug":"frp","date":"2021-03-12T15:50:36.000Z","updated":"2021-03-13T06:53:42.544Z","comments":true,"path":"undefined/773c1282.html","link":"","permalink":"https://franxhao.top/undefined/773c1282.html","excerpt":"前言在计算机网络的课上，留意到老师都是通过远程连接来将办公室的电脑和教室的电脑进行连接，我很好奇！刚好之前我的树莓派就是通过VNC远程连接来实现桌面连接，所以就想折腾下Windows的远程连接。其实并不难，在局域网内，通过 Win + R 输入 mstsc 打开Windows远程桌面程序，输入局域网内想要连接的电脑的IP，然后输入密码就可以连接到另一台电脑上。 当然这是需要前期准备工作的，比较老的系统，如Win7打开远程桌面服务比较麻烦，如果没有密码还需要设置密码，当然没有密码也可以远程登录啦，直接回车回车… 而Win10就很方便，现在最新的Win10系统设置的UI界面越来越扁平化，直接就可以找到远程桌面这一项，一键开启即可！具体如何开启远程可以找度娘。 回归正题，当我不在局域内，又想远程访问远在天边的电脑，该怎么办呢，这时就有了这篇折腾frp非局域网下实现Windows远程的文章～～～","text":"前言在计算机网络的课上，留意到老师都是通过远程连接来将办公室的电脑和教室的电脑进行连接，我很好奇！刚好之前我的树莓派就是通过VNC远程连接来实现桌面连接，所以就想折腾下Windows的远程连接。其实并不难，在局域网内，通过 Win + R 输入 mstsc 打开Windows远程桌面程序，输入局域网内想要连接的电脑的IP，然后输入密码就可以连接到另一台电脑上。 当然这是需要前期准备工作的，比较老的系统，如Win7打开远程桌面服务比较麻烦，如果没有密码还需要设置密码，当然没有密码也可以远程登录啦，直接回车回车… 而Win10就很方便，现在最新的Win10系统设置的UI界面越来越扁平化，直接就可以找到远程桌面这一项，一键开启即可！具体如何开启远程可以找度娘。 回归正题，当我不在局域内，又想远程访问远在天边的电脑，该怎么办呢，这时就有了这篇折腾frp非局域网下实现Windows远程的文章～～～ 因作者学业繁忙，没能及时完成这篇文章，在填坑本文的时候已经隔了很多时间，后面的步骤可能会有些紊乱，请谅解。待后期有机会再做一次这项工程时，我会同步更新本文，并附上相应的截图。 前期准备 一台VPS公网服务器 开启端口 Github下载相关文件 Github内搜索frp，进入开源项目后找到releases 放开端口因为我的服务器是腾讯云的，以腾讯云为例(放通6000，7000端口) SSH连接服务器安全组放开后只是能去这两个端口，服务器的这两个端口还是没有打开，所以得通过命令打开服务器的这两个端口 12345firewall-cmd --permanent --add-port=6000/tcp --&gt;开启6000端口firewall-cmd --permanent --add-port=7000/tcp --&gt;开启7000端口firewall-cmd --reload --&gt;重启firewall让修改的配置生效firewall-cmd --query-port=6000/tcp --&gt;查看6000端口是否开启firewall-cmd --query-port=000/tcp --&gt;查看7000端口是否开启 出现success 或 yes 字样时即为开启成功 frp下载传送门:https://github.com/fatedier/frp/releases amd64为64位使用，386是32位使用,选择对应版本下载。下载的包可以通过宝塔上传并解压到服务器的根目录下。也可以通过Linux指令进行下载和解压 123wget https://github.com/fatedier/frp/releases/download/v0.34.3/frp_0.34.3_linux_amd64.tar.gztar -zxvf frp_0.34.3_linux_amd64.tar.gz 下载完成后，在命令行中可以看到 frp_0.34.3_linux_amd64 文件夹，我们cd一下进入该文件夹中，可以看到 frpc、frpc_full.ini、frpc.ini、frps、frps_full.ini、frps.ini、LICENSE、systemd 这几个文件，其中 frpc、frpc.ini 这个两个是客户端的文件，可以通过Linux指令删除（frpc_full.ini这个可能也是客户端文件，具体功能我还没有仔细了解，我没有删除这个文件）。 编辑配置文件服务器端配置 frpc —&gt; 字面上可以看出是frp client，也就是客户端frps —&gt; 即frp server，也就是服务器接下来我们需要修改配置文件，也就是frps.ini，按个人喜好用vi或者nano指令进行编辑；来看一下我这里的服务器端的配制文件： 1234//服务器端配置[common]bind_port = 7000token = aaabbbccc //这里就是客户端与我们服务器端frp进行链接时的密码，越复杂越好 配置完成后，输入指令：./frps -c ./frps.ini ---&gt;服务端启动frp可以看到提示start frps success（frps开启成功） 客户端配置在客户端机子下载相应的frp文件，以我的电脑为例（Windows 10）：frp_0.34.3_windows_amd64 （注意客户端和服务器端版本要对应），文件夹可以放到任意盘，进入文件夹配置frpc.ini，Windows系统可以用记事本打开进行配置： 1234567891011//客户端配置[common]server_addr = ***.***.*** //你的域名或IPserver_port = 7000 //这个就是指我们在服务器端监听我们客户端的端口号与上面保持一致token = aaabbbccc //这个就是我们服务器端设置的密码要保持一致不然会无法连接[rdp]type = tcplocal_ip = 127.0.0.1local_port = 3389remote_port = 6000 配置好保存退出后，在这个文件夹中 按住Shift + 右单击，在下拉菜单栏中单击 在此处打开PowerShell窗口 ，输入指令 ：.\\frpc.exe -c .\\frpc.ini ，当出现success字样的时候就表示已经成功连接到服务器了。 这里注意一下，windows一般为反斜杠 \\ ，所以输入的指令不是 ./frpc.exe -c ./frpc.ini 相关问题frp服务搭建成功后先别急着高兴，还有一些小问题需要解决。虽然服务器上还可以运行，但一旦我们断开ssh，我们建立的frps进程也会被kill，这时就要用到一个工具 —&gt; screen 安装screen服务yum install screen -y 安装完成后，用screen新建一个会话，在这里面运行frps，退出ssh后它也不会结束进程：screen -S frp 新建完成之后输入 nohup ./frps -c ./frps.ini -&amp; ，nohup是让它后台运行，-&amp;是锁定它不让它结束进程，此时即使断开了ssh我们仍可以进行连接，除非服务器重启… 关闭防火墙如果出现无法连接的问题，有可能是需要关闭防火墙输入以下指令即可： 12345systemctl stop firewalldsystemctl disable firewalld//orsystemctl stop iptablessystemctl disable iptables 非局域网远程连接Windows所有配置工作都做完后我们就可以进行远程连接了，在另一台计算机上 Win + R 后输入mstsc进入Windows远程桌面，输入服务器IP后点击连接，然后成功输入Windows密码，即可成功连接到自己的电脑。在移动端远程也是可以实现的，例如我会使用iPad对我的电脑进行远程，只需下载微软官方软件 RD Client，同样输入相关IP和密码后就可以实现移动端远程。 注意两台设备需在非同一网络下进行实验需要使用该服务时，服务器和客户端都必须打开fps服务，任何一方服务停止都无法连接成功服务器端一般是已经配置好可以不用动了，客户端如上述打开服务出现success字样即可","categories":[{"name":"系统","slug":"系统","permalink":"https://franxhao.top/categories/%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"frp","slug":"frp","permalink":"https://franxhao.top/tags/frp/"}]},{"title":"双线部署 Coding Pages 和 GitHub Pages 并实现全站 HPPTS","slug":"coding","date":"2020-08-29T06:49:39.000Z","updated":"2020-08-29T08:31:00.523Z","comments":true,"path":"undefined/f82c66a5.html","link":"","permalink":"https://franxhao.top/undefined/f82c66a5.html","excerpt":"以前我的静态站是双线部署在Github Page 和 Gitee Page 上的，域名是指向Github上的所以每次访问我的静态站速度都很头疼，Gitee Page 服务每次都需要手动更新部署，而且部署速度有时也挺慢的，所以前段时间是想渐渐退出静态站的，直到后来我发现了 Coding Page 可以免费自动更新部署，而且在国内的访问速度也非常可观，让我重新燃起继续完善静态站的想法！ Coding Page 服务还可以绑定自己的域名（包括国外服务商购买的域名），这服务这么香，赶紧搞起来吧 o(*≧▽≦)ツ ～","text":"以前我的静态站是双线部署在Github Page 和 Gitee Page 上的，域名是指向Github上的所以每次访问我的静态站速度都很头疼，Gitee Page 服务每次都需要手动更新部署，而且部署速度有时也挺慢的，所以前段时间是想渐渐退出静态站的，直到后来我发现了 Coding Page 可以免费自动更新部署，而且在国内的访问速度也非常可观，让我重新燃起继续完善静态站的想法！ Coding Page 服务还可以绑定自己的域名（包括国外服务商购买的域名），这服务这么香，赶紧搞起来吧 o(*≧▽≦)ツ ～ 创建Coding项目1、创建一个Coding的账号。现在的Coding是以团队的方式加入，身边没有Coding团队的小伙伴可以自己创建一个团队，身边有人有团队的话可以申请加入，这样就可以省去创建团队的功夫啦。 2、账号创建好后，找到 个人账户设置 ，将本地生成的SSH公钥添加进去。（同Github上的设置）一般公钥路径在 C:\\Users\\用户名\\.ssh 目录下的 id_rsa.pub 文件里，用记事本打开，将所有内容复制出来即可。 3、实名认证。 必须实名认证才可以设置部署静态网站。 4、创建一个托管静态页面的项目 选择代码托管项目（或选择DevOps项目） 项目名称建议是使用自己在Coding上设置的用户名 进入刚创建的仓库，复制SSH的路径（据说SSH比较稳定） 配置到Hexo并部署到Coding1、配置主站目录下的 _config.yml 1234567deploy: type: git repo: github: (自己的SSH) coding: (自己的SSH) #gitee: (自己的SSH) branch: master 2、执行三件套指令 1hexo clean &amp;&amp; hexo g -d 3、部署到Coding 打开持续部署开关 部署静态网站 部署完成后点开上面的访问地址可以打开你的Hexo博客说明已经部署成功啦 添加自定义域名首先需要拥有一个域名，国内购买的域名需要进行备案，国外域名商购买的域名可以不进行备案 本站域名是在国外域名平台 Namesilo 购买，是目前价格较便宜的域名平台，支持支付宝，提供免费的域名隐私保护，性价比较高。 关于Namesilo域名购买可以查找度娘或者看以下这篇文章： https://tding.top/archives/b48e2719.html 域名解析我使用的是DNSPod 添加解析记录1、ping一下Coding给你Hexo项目部署到的地址，获得Coding Page 的IP地址 2、在DNSPod中添加两条解析记录： 记录类型为 A ，主机记录为 @ ，解析线路选择默认，记录值为ping到的Coding Page的IP地址 记录类型为 CNAME ，主机记录为 www ，解析线路选择默认，记录值为Coding给你Hexo项目部署到的地址，例如我的是https://f4kp1l.coding-pages.com 3、将Github的解析线路选择国外，这样就可以确保国内访问都是走Coding这边 具体如下图： 绑定自定义域名在Coding的项目中，找到 持续部署→静态网站→设置 ，拉到下面的自定义域名，绑定新域名 Tips：注意：一定要选首选的域名，并且非首选域名要勾选跳转至首选域名 开启HTTPS打开强制HTTPS开关会自动申请证书，如果你之前已经部署到了 GitHub Pages 并开启了 HTTPS，那么直接在设置页面绑定你自己的域名，SSL/TLS 安全证书就会显示申请错误。 申请错误原因是：在验证域名所有权时会定位到 Github Pages 的主机上导致 SSL 证书申请失败。 正确的做法是：先去域名 DNS 把 GitHub 的解析暂停掉，然后再重新申请 SSL 证书，大约十秒左右就能申请成功，然后开启强制 HTTPS 访问。 参考文章Hexo 博客部署到 Coding动态站文章地址https://haozsky.top/archives/14/欢迎光临我的动态站","categories":[{"name":"博客","slug":"博客","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"博客/Hexo","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://franxhao.top/tags/Hexo/"}]},{"title":"博客颜色字体用法整理","slug":"ziticolor","date":"2020-08-23T17:50:45.000Z","updated":"2020-08-23T19:50:58.863Z","comments":true,"path":"undefined/66da368c.html","link":"","permalink":"https://franxhao.top/undefined/66da368c.html","excerpt":"在写文章的时候为了让某些内容更醒目，除了想到加粗、添加代码条、引用内容…之外，还可以通过改变字体颜色来突显不同。当然啦，在博客美化中也常会在很多地方会用到颜色，而每种颜色都对应着相应的色号？咳咳不对，我想说的是十六进制值，但是颜色有好几百上千种，我们又记不得这么多代码，去搜查还会浪费很多宝贵时间，真的是脑壳疼……前两天看到的一篇相关内容的文章，在这里给自己整理一下以后就不用花太多时间去找了","text":"在写文章的时候为了让某些内容更醒目，除了想到加粗、添加代码条、引用内容…之外，还可以通过改变字体颜色来突显不同。当然啦，在博客美化中也常会在很多地方会用到颜色，而每种颜色都对应着相应的色号？咳咳不对，我想说的是十六进制值，但是颜色有好几百上千种，我们又记不得这么多代码，去搜查还会浪费很多宝贵时间，真的是脑壳疼……前两天看到的一篇相关内容的文章，在这里给自己整理一下以后就不用花太多时间去找了 1、代码示例1234567在Hexo中：&lt;font color&#x3D;&quot;red&quot;&gt;这里是红色&lt;&#x2F;font&gt;在Typecho中：!!!&lt;font color&#x3D;&quot;red&quot;&gt;这里是红色&lt;&#x2F;font&gt;!!! 效果：这里是红色 在Hexo中不用输入!，否则会直接输出! ；在Typecho中需要!，否则无法显示颜色 2、HTML5 CSS3颜色十六进制值演示站DEMO演示站：http://colors.cchosts.cn/ 3、color颜色代码大全： 序号 颜色名称 对应代码 序号 颜色名称 对应代码 1 白颜色(例) #FFFFFF 11 蓝紫色(例) #9F5F9F 2 红颜色(例) #FF0000 12 黄铜色(例) #B5A642 3 绿颜色(例) #00FF00 13 亮金色(例) #D9D919 4 蓝颜色(例) #0000FF 14 棕色(例) #A67D3D 5 牡丹红(例) #FF00FF 15 青铜色(例) #8C7853 6 青颜色(例) #00FFFF 16 2号青铜色(例) #A67D3D 7 黄颜色(例) #FFFF00 17 士官服蓝色(例) #5F9F9F 8 黑颜色(例) #000000 18 冷铜色(例) #D98719 9 海颜蓝(例) #70DB93 19 铜色(例) #B87333 10 巧克力色(例) #5C3317 20 珊瑚红(例) #FF7F00 例色工程量有点大，后面暂时不添加例色 序号 颜色名称 对应代码 序号 颜色名称 对应代码 21 紫蓝色 #42426F 31 深绿松石色 #7093DB 22 深棕 #5C4033 32 暗木色 #855E42 23 深绿 #2F4F2F 33 淡灰色 #545454 24 深铜绿色 #4A766E 34 土灰玫瑰红色 #856363 25 深橄榄绿 #4F4F2F 35 长石色 #D19275 26 深兰花色 #9932CD 36 火砖色 #8E2323 27 深紫色 #871F78 37 森林绿 #238E23 28 深石板蓝 #6B238E 38 金色 #CD7F32 29 深铅灰色 #2F4F4F 39 鲜黄色 #DBDB7 30 深棕褐色 #97694F 40 浅木色 #E9C2A6 序号 颜色名称 对应代码 序号 颜色名称 对应代码 41 石灰绿色 #32CD32 51 中春绿色 #7FFF00 42 桔黄色 #E47833 52 中绿松石色 #70DBDB 43 褐红色 #8E236B 53 中紫红色 #DB7093 44 中海蓝色 #32CD99 54 中木色 #A68064 45 中蓝色 #3232CD 55 深藏青色 #2F2F4F 46 中森林绿 #6B8E23 56 海军蓝 #23238E 47 中鲜黄色 #EAEAAE 57 霓虹篮 #4D4DFF 48 中兰花色 #9370DB 58 霓虹粉红 #FF6EC7 49 中海绿色 #426F42 59 新深藏青色 #00009C 50 中石板蓝色 #7F00FF 60 新棕褐色 #EBC79E 序号 颜色名称 对应代码 序号 颜色名称 对应代码 61 暗金黄色 #CFB53B 71 猩红色 #BC1717 62 橙色 #FF7F00 72 海绿色 #238E68 63 橙红色 #FF2400 73 半甜巧克力色 #6B4226 64 淡紫色 #DB70DB 74 赭色 #8E6B23 65 浅绿色 #8FBC8F 75 银色 #E6E8FA 66 粉红色 #BC8F8F 76 天蓝 #3299CC 67 李子色 #EAADEA 77 石板蓝 #007FFF 68 石英色 #D9D9F3 78 艳粉红色 #FF1CAE 69 艳蓝色 #5959AB 79 春绿色 #00FF7F 70 鲑鱼色 #6F4242 80 钢蓝色 #236B8E 序号 颜色名称 对应代码 序号 颜色名称 对应代码 81 亮天蓝色 #38B0DE 86 淡浅灰色 #CDCDCD 82 棕褐色 #DB9370 87 紫罗兰色 #4F2F4F 83 紫红色 #D8BFD8 88 紫罗兰红色 #CC3299 84 石板蓝色 #ADEAEA 89 麦黄色 #D8D8BF 85 浓深棕色 #5C4033 90 黄绿色 #99CC","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://franxhao.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://franxhao.top/tags/Hexo/"}]},{"title":"Hexo发布文章报错can not read a block mapping entry","slug":"post-error1","date":"2020-08-17T17:05:30.000Z","updated":"2020-08-17T17:40:32.127Z","comments":true,"path":"undefined/6df7f115.html","link":"","permalink":"https://franxhao.top/undefined/6df7f115.html","excerpt":"","text":"今天在修改文章标题的时候报错了，我直接改标题没有动到下面的信息（冒号后都已空一格），但是在生成静态的时候给我反馈了如下错误： YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 2, column 4: 经过Google查找发现是标题配置里面有&quot; &quot;和( )这类英文符号，导致文章无法按照正确YAML语法解析而出错，把它们改成中文符号就好了。 通过此次踩坑发现，文章头部配置要严格按照YAML语法来写。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://franxhao.top/categories/Hexo/"},{"name":"踩坑记录","slug":"Hexo/踩坑记录","permalink":"https://franxhao.top/categories/Hexo/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://franxhao.top/tags/Hexo/"}]},{"title":"Typecho主站崩溃与自建RSSHub和跨域服务","slug":"typecho-rsshub","date":"2020-08-15T13:52:33.000Z","updated":"2020-08-20T18:29:13.665Z","comments":true,"path":"undefined/2dcf1105.html","link":"","permalink":"https://franxhao.top/undefined/2dcf1105.html","excerpt":"前几天发现我的动态主站崩溃了（2020.8.12），通过域名打开直接出现的是PHP源码，一番折腾后虽然能进主页了，但是所有子页面都无法打开，网页显示 404 Not Found nginx ，苦于我这嵌入式方向专业的童鞋没有前端基础折腾了好久没办法修复，只能删库重建网站了。更痛心的是数据库也因保存错误数据导致数据无法恢复了……我的头发白掉了啊(ㄒoㄒ) 经过和重建网站的Nginx配置对比，为什么出问题自己心里算是有些眉目了，两份Nginx配置内容有很大差别，说明是在某个时候这份配置被覆盖了，为什么会被覆盖？将在文章RSSHub和跨域服务搭建过程中说明……","text":"前几天发现我的动态主站崩溃了（2020.8.12），通过域名打开直接出现的是PHP源码，一番折腾后虽然能进主页了，但是所有子页面都无法打开，网页显示 404 Not Found nginx ，苦于我这嵌入式方向专业的童鞋没有前端基础折腾了好久没办法修复，只能删库重建网站了。更痛心的是数据库也因保存错误数据导致数据无法恢复了……我的头发白掉了啊(ㄒoㄒ) 经过和重建网站的Nginx配置对比，为什么出问题自己心里算是有些眉目了，两份Nginx配置内容有很大差别，说明是在某个时候这份配置被覆盖了，为什么会被覆盖？将在文章RSSHub和跨域服务搭建过程中说明…… RSSHub：万物皆可 RSS RSSHub 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。RSSHub 借助于开源社区的力量快速发展中，目前已适配数百家网站的上千项内容。 1.利用宝塔PM2搭建RSSHub RSSHub项目地址：DIYgod/RSSHub 对于小白来说，宝塔面板的PM2管理器非常方便，使用云服务器建站用起来容易上手。 1.1 clone源码到root目录下1git clone https:&#x2F;&#x2F;github.com&#x2F;DIYgod&#x2F;RSSHub.git 可能是因为RSSHub项目被墙的缘故，项目网页需要翻墙才可以打开，所以难免会出现clone速度很慢的同学，我们可以采用其他办法将源码下载出来，上传到root目录下，命名为RSSHub即可。解决办法：使用代理下载速度快的同学可以直接将源码压缩包下载出来，解压并将RSSHub文件夹通过宝塔上传至root目录中利用Gitee导入Github仓库功能，直接clone导入到Gitee仓库的RSSHub项目即可解决 1.2 安装PM2管理器，启动RSSHubPM2管理器在宝塔面板软件商店中搜索找到并安装。 启动RSSHub 命令行法添加项目 12cd RSSHubpm2 start lib&#x2F;index.js --name rsshub 命令行添加法优点是添加项目速度快，但是在PM2中有可能会无法打开项目目录导致最终搭建失败 PM2添加法 添加好后点击「映射」，设置域名，如图： 设置的域名可以到你的域名解析里添加一个子域名映射到服务器IP即可。子域名例如rsshub.xxx.com中的rsshub部分可随意设置解析好子域名后顺便去申请个SSL证书，并在宝塔站点中开启子域名的SSL，如果不支持https会造成浏览器加载失败必须映射到根目录RSSHub中，宝塔有可能会默认映射到www目录中，如果映射到www目录可能会导致覆盖Typecho网站的Nginx配置，从而使网站出现各种错误，这就是我主站崩溃的原因 最后在浏览器中打开你设置映射的域名(https://rsshub.xxx.com)看到RSSHub的图标并且显示Welcome to RSSHub!字样的页面说明搭建成功！ 2. 利用宝塔Docker 部署RSSHub 可参考班班的文章：宝塔面板部署 RSSHub 和自动签到 Docker 应用 3. 跨域服务跨域最简单的解决办法是：在原有的RSS源地址前面加上https://cors-anywhere.herokuapp.com/ 例如https://cors-anywhere.herokuapp.com/https://rsshub.xxx.com/rss路由 但是这个方法访问速度比较慢，我这甚至出现了无法加载的情况，所以我们需要自己搭建一个跨域服务： proxy(HTTP请求代理，CORS跨域请求，HTTPS支持) 安装123git clone https:&#x2F;&#x2F;github.com&#x2F;netnr&#x2F;proxy.gitcd proxynpm install 如果clone不到使用，解决方法同上RSSHub，安装目录依旧是在根目录root下。 PM2管理器添加项目添加项目同RSSHub的PM2添加法，启动文件为server.js，项目名称可随意。添加好后点击「映射」，设置域名。（这里域名需要再解析一个新的子域名并申请SSL证书，记得在宝塔添加证书开启SSL） 这时自己搭建的跨域服务为：https://proxy.xxx.com/ 此时自己的代理为：https://proxy.xxx.com/https://rsshub.xxx.com/rss路由，浏览器打开代理可以看到爬到的RSS源代码说明成功啦，同时可以发现自建跨域服务速度飞快（/赞） 4. 订阅RSS源有了以上准备就可以订阅其他网站的RSS源啦，这里以B站为例： 123456789用户追番列表作者: @wdssmq举例: https:&#x2F;&#x2F;rsshub.app&#x2F;bilibili&#x2F;user&#x2F;bangumi&#x2F;208259路由: &#x2F;bilibili&#x2F;user&#x2F;bangumi&#x2F;:uid参数:uid, 必选 - 用户 id 这时搭配上自建的两个服务后url就是： https://proxy.xxx.com/https://rsshub.xxx.com/bilibili/user/bangumi/:uid 具体RSS源网站内容聚合在时光机页面内的配置可参见handsome文档RSSHub具体的配置和路由可参见RSSHub文档（RSSHub文档目前好像也被墙了） 参考文章： https://www.anleenoxu.top/archives/156.htmlhttps://www.jellyw.com/archives/170/","categories":[{"name":"博客","slug":"博客","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"Typecho","slug":"博客/Typecho","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/Typecho/"}],"tags":[{"name":"Typecho","slug":"Typecho","permalink":"https://franxhao.top/tags/Typecho/"},{"name":"RSSHub","slug":"RSSHub","permalink":"https://franxhao.top/tags/RSSHub/"}]},{"title":"【Pi】VNC远程连接树莓派和WiFi模块的开启","slug":"raspberry-pi-1","date":"2020-08-03T06:59:39.000Z","updated":"2021-06-08T16:24:02.492Z","comments":true,"path":"undefined/66fbe44e.html","link":"","permalink":"https://franxhao.top/undefined/66fbe44e.html","excerpt":"前 言前段时间在腾讯云买了台云服务器，随后又开始了解到树莓派也可以用来搭建服务器，毕竟作为技术型学生，对技术的学习总有着探索和热情之心。所以入手了一块树莓派4B（2G），打算用来搭建属于自己的服务器，同时开启了Linux学习之路(ง •̀_•́)ง…… 今天记录一下成功用VNC进行远程连接还有成功用上WiFi功能！Ｏ(≧▽≦)Ｏ","text":"前 言前段时间在腾讯云买了台云服务器，随后又开始了解到树莓派也可以用来搭建服务器，毕竟作为技术型学生，对技术的学习总有着探索和热情之心。所以入手了一块树莓派4B（2G），打算用来搭建属于自己的服务器，同时开启了Linux学习之路(ง •̀_•́)ง…… 今天记录一下成功用VNC进行远程连接还有成功用上WiFi功能！Ｏ(≧▽≦)Ｏ VNC远程连接树莓派4B自带VNC，我们不需要再使用指令安装 前期需要： 树莓派的IP地址：给树莓派插上网线，在同一个内网（局域网）下，可以登录路由器管理界面查看树莓派的IP。 使用SSH远程树莓派（可以通过XShell、PuTTY或者SSH远程指令） XShell6下载 v6.0.0086 64位破解版：下载地址里面用普通下载地址下载即可，高速下载器通道会附有垃圾软件。 SSH远程指令：ssh pi@树莓派的IP地址 在自己的电脑上安装VNC。VNC是一款远程桌面软件，支持Windows、Mac、iOS、Linux、树莓派操作系统，而且树莓派自带VNC，只需要远程打开它就好了。 接下来是远程配置树莓派，指令为 sudo raspi-config 在终端/运行中键入以上指令后的现象如下图所示，选择步骤：5 Interfacing Options → P3 VNC → 是 → 确定 →Finish。 配置完成后树莓派上的VNC就可以使用了。 在终端中输入指令 vncserver 后，等待字符跑完……然后如下图看到的，结束后最后一行的IP就是我们需要的，他告诉我们树莓派桌面的IP地址为192.168.3.20，端口号为1，有了这个我们就可以通过自己的电脑上的VNC远程树莓派了。 VNC远程树莓派操作和XShell远程操作相似就不在加以叙述。 其实还可以通过手机或平板（ios端）对树莓派进行远程，只要在App Store中下载VNC，进行远程操作后就可以实现啦。 开启树莓派无线上网模式树莓派4B内置有WiFi模块，可以不用外接无线网卡实现WiFi上网功能，下面将简单写下WiFi模块的开启。 在程序烧录进SD卡完成后，在boot中新建 wpa_supplicant.conf 文件，并写入无线的相关配置。 12345678910country&#x3D;CNctrl_interface&#x3D;DIR&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant GROUP&#x3D;netdevupdate_config&#x3D;1 network&#x3D;&#123; ssid&#x3D;&quot;wi-fi name here&quot; psk&#x3D;&quot;wi-fi password here&quot; key_mgmt&#x3D;WPA-PSK priority&#x3D;1&#125; WiFi 配置示例说明： ssid:网络的ssid psk:密码 priority:连接优先级，数字越大优先级越高（不可以是负数） 如果有两个就在下面多添加一个network的代码并标好优先级就可。 若SD卡已经插入树莓派中，但又想修改文件中的内容可以使用指令来完成，在终端中输入以下指令打开文件 sudo nano /etc/wpa_supplicant/wpa_supplicant.conf 可以用vim或nano编辑，这里使用nano，nano编辑完后先按Ctrl+O再按Enter对修改内容进行保存，再按Ctrl+X退出回到原来的终端界面。 以上就是这次对树莓派这块小玩意做的小总结啦~","categories":[{"name":"Pi","slug":"Pi","permalink":"https://franxhao.top/categories/Pi/"},{"name":"树莓派","slug":"Pi/树莓派","permalink":"https://franxhao.top/categories/Pi/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://franxhao.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"【C51单片机】（二）实验一升级，进阶+复习！","slug":"单片机2","date":"2020-05-01T15:45:29.000Z","updated":"2021-06-12T13:05:02.346Z","comments":true,"path":"undefined/6e490410.html","link":"","permalink":"https://franxhao.top/undefined/6e490410.html","excerpt":"1. 前情提要通过 实验一 我们知道，单片机（以AT89C51为例）I/O端口需要通过对应的十六进制代码来使用，通过编程每一个按钮实现的功能都不一样。嘿嘿，这期我们升级一下，通过按下两个按钮来实现他们的功能 ─=≡Σ((( つ•̀ω•́)つ Let’s go!","text":"1. 前情提要通过 实验一 我们知道，单片机（以AT89C51为例）I/O端口需要通过对应的十六进制代码来使用，通过编程每一个按钮实现的功能都不一样。嘿嘿，这期我们升级一下，通过按下两个按钮来实现他们的功能 ─=≡Σ((( つ•̀ω•́)つ Let’s go! 2. 实验题目P1接8个灯，P3.2、P3.3、P3.4、P3.5接4个按钮（以实验一为基础） 选择其中两个开关，完成按下一个开关流水灯顺着循环滚动不停，按下另一个，流水灯逆着滚动不停 （本次实验仅实现题目功能，其他功能观众有兴趣的话可以继续造 o(￣▽￣)o 捏嘿） 2.1 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;reg51.h&gt;void delay(unsigned int time) //延时函数&#123; unsigned i,j; for(i=0;i&lt;time;i++) for(j=0;j&lt;1000;j++) ;&#125;void main()&#123; unsigned int y,m,n; unsigned int a[8]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f&#125;; unsigned int b[8]=&#123;0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe&#125;; //a、b为顺逆流值 unsigned int c[4]=&#123;0xfb,0xf7,0xef,0xdf&#125;; //只按一个按钮的值 unsigned int d[6]=&#123;0xf3,0xeb,0xdb,0xe7,0xd7,0xcf&#125;; //按两个按钮时的值 while(1) &#123; for(m=0;m&lt;4;m++) //当只按一个按钮时顺流 &#123; if(P3==c[m]) &#123; for(y=0;y&lt;8;y++) &#123; P1=a[y]; delay(20); &#125; &#125; else P1=0xff; &#125; for(n=0;n&lt;6;n++) //当按下两个按钮时逆流 &#123; if(P3==d[n]) &#123; for(y=0;y&lt;8;y++) &#123; P1=b[y]; delay(20); &#125; &#125; else P1=0xff; &#125; &#125; &#125; 心得体会： 因为刚接触这门课，萌新的我花了很长时间才将题目功能实现出来QAQ。当时编写出现的问题是①按下按钮都无法实现功能和②按下一个按钮流水灯能发生顺流而按下第二个按钮或相隔的按钮时无法进行逆流，所以我认为可以从②中寻找为何按下第二个按钮或相隔按钮时无法逆流的问题。 当时和好友一起讨论的时候我注意到了他的一句话 “按两个按钮就是1111 0011，也就是0xf3了 ” ，因为这句话我得到了灵感，那就是把任意两个按钮同时按下时的十六进制值写数组中，这样就像只按一个按钮的数组一样。当然，顺逆流的循环可以优化一下省去一部分代码，而且我在网上找过很多方法，可能在选择按钮中会有更简便的写法。 2.2 仿真演示 本代码可以实现按下任意两个开关流水灯都可以进行逆流。 按下一个开关时：（这里以按下P3.3开关为例） 按下两个开关时： 如按下P3.3和P3.5开关：（相隔按钮） 如按下P3.4和P3.5开关：（相邻按钮） 3. 小结这次实验对于实验一来说是一次升格，因为通过双开关这一步更加加深了对I/O端口的了解和运用，是流水灯实验中一道不错的综合题。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C51单片机","slug":"嵌入式/C51单片机","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/C51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"C51单片机","slug":"C51单片机","permalink":"https://franxhao.top/tags/C51%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"进阶之路！从0开始搭建Hexo博客（二）","slug":"hexo-create-2","date":"2020-04-11T23:01:22.000Z","updated":"2020-08-17T17:30:50.517Z","comments":true,"path":"undefined/91ba00fe.html","link":"","permalink":"https://franxhao.top/undefined/91ba00fe.html","excerpt":"","text":"1.Hexo安装接上一篇 在Git中输入npm -v和node -v，若出现版本号说明node安装成功。输入npm install hexo-cli -g安装Hexo，安装完成后即可退出Git。 在任意磁盘中新建一个文件夹来放配置文件，比如在D盘中新建了一个文件夹命名为“Myblog”；打开你的文件夹，然后在空白处点鼠标的右键，选择Git Bash Here；在Git中输入命令hexo init安装相关配置。 等待安装完毕后，最后一句出现 INFO Start blogging with hexo 说明Hexo已经搭建成功了。 搭建完成后可输入命令 npm install 和 npm install hexo-deployer-git --save 方便今后部署。 2.运行测试首先介绍一下今后写博客时会经常用到的命令： 1234hexo clean #用来清理缓存文件hexo s #运行本地服务器hexo g #生成静态文件hexo d #上传到服务器 博客搭建成功后，输入命令 hexo s (hexo server) 运行本地服务器 打开浏览器，输入localhost:4000，看到以下页面说明本地环境搭建完成 3.部署到云端将博客部署到远端后别人才可以访问到你的网站，这里以GitHub为例。 首先在你所建立的blog文件夹根目录下找到_config.yml也就是站点配置文件，用编辑器打开文件。打开后拉到最下面找到deploy，做以下修改： 地址我使用的是SSH的地址，修改完成后保存配置文件。 在Git命令输入框中输入命令hexo g（hexo generate）在本地生成静态文件。再次输入hexo s可预览是否有问题，没有问题后按Ctrl+C退出预览，输入hexo d就可以上传至GitHub云端啦。 当然，今后写博客想要一步到位的话也可以使用一键三杀： hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 或 hexo clean &amp;&amp; hexo g -d 4.更换主题Hexo的主题可以在官网的主题里找到自己喜欢的主题，点击主题名可以进入到主题的GitHub地址，里面会有相关主题的安装和配置说明等。 主题安装完成后需要在博客的站点配置文件中找到theme:，并将其原来的landscape主题改成自己下载的主题的名字，主题名为themes文件目录中的主题文件名 这里以我用的next主题为例 主题更换好后再来一次hexo s就能预览到自己更换的主题啦。关于主题的美化大家可以自己去研究，网上关于Hexo的文章有很多，出现问题一般都比较容易找到。关于next主题美化这里推荐以下参考视频： UP主dp2px_com: https://www.bilibili.com/video/BV1VE411k7jP https://www.bilibili.com/video/BV1LE411k7SR 后记“从0开始搭建Hexo博客”系列到这里就完结了，因为搭建过程需要更直观的表达会更好些，文字工程量其实是挺大的，所以该文章主要是基于UP主的视频所写，有不懂的地方可以去看视频，里面的操作会更直观。 tips： 配置文件中，冒号后（如theme:）必须要空一格才能输入东西。主题文件中也有配置文件，和站点的配置文件名字相同但是用途不同，需要注意分清楚。 关于部署方面其实有很多选择，除GitHub外，类似的还有Gitee和Coding，GitHub主要是国外的所以可能会导致别人的访问速度方面的体验跟不上，当然像Gitee等国内的Page服务体验也会有所不同。 关于主题方面大家可以自己慢慢探索，美化主题不是一天就能完成的事，就像记单词一样，一点一点地发现和积累，最终就可以美化成为你所希望的主题。 最后祝大家能够做出属于自己的博客","categories":[{"name":"博客","slug":"博客","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"博客/Hexo","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://franxhao.top/tags/Hexo/"}]},{"title":"新技能加点！从0开始搭建Hexo博客（一）","slug":"hexo-create","date":"2020-04-04T15:10:27.000Z","updated":"2020-08-17T17:31:00.622Z","comments":true,"path":"undefined/80342cee.html","link":"","permalink":"https://franxhao.top/undefined/80342cee.html","excerpt":"","text":"特别感谢以下UP主的教学视频：①CodeSheep: 传送门：https://www.bilibili.com/video/BV1Yb411a7ty ②Master_lisa: 传送门：https://www.bilibili.com/video/BV1A4411G7SF 前情提要：我的搭建系统是windows 10，流程根据UP主Master_lisa的视频来写。OK,Here we go！ 1.提前准备 创建Github/Gitee(码云)： 用户名都是最好用小写字母，可以加数字。创建好后点击网页右上角+号创建新库，如下图： 新建库时应严格按照①中用户名，以这种xxx.github.io形式(②)输入： 输入完毕后点击下方绿色按钮Create repository就完成建库啦。 安装 Node.js：https://nodejs.org 安装步骤很简单，一直next，默认安装就行。 安装Git：https://git-scm.com/downloads 安装步骤也是一直点下一步，按官方默认的来装就行。（路径可选） tips：Git安装完成后，发现右键有Git的功能快捷键，我们主要用Git Bash。 2.配置Git在Git安装目录下右键点击Git Bash Here，在终端窗口配置好你的用户名和邮箱： $ git config --global user.name &quot;John Doe&quot;（“John Doe”为你要输入的用户名） $ git config --global user.email &quot;johndoe@example.com&quot;（email后填你的邮箱） 配置好后可以输入以下检查是否配置成功，如果输出结果是你输入的东西就是配置成功了： $ git config --global user.name $ git config --global user.email tips：以上只需复制$符号之后的代码即可；在Git中复制粘贴不能使用ctrl+c/v，只能老老实实用鼠标。 3.配置SSH 继续在终端窗口输入：ssh-keygen -t rsa -C &quot;johndoe@example.com&quot;，在接下来全部按回车键，出现选项选y然后继续回车。出现下图样式说明成功： 这时可以按配置里说的public key的地址去找到自己的ssh公钥。一般在C:\\Users\\Admin中出现.ssh文件夹，右击该文件夹里的id_rsa.pub以记事本形式打开，里面就是你的SSH公钥。 将SSH配置到Github上。在Github上点击头像，找到Settings点击进入，找到左栏的SSH and GPG keys。然后点击New SSH key。 输入以下检验是否配置成功： $ ssh git@github.com $ ssh -T git@github.com 若都出现You’ve successfully authenticated字样就是配置成功了。 ←To Be Continued","categories":[{"name":"博客","slug":"博客","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"博客/Hexo","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://franxhao.top/tags/Hexo/"}]},{"title":"【C51单片机】（一）4个按钮8盏灯，实现四种功能","slug":"单片机1","date":"2020-04-01T23:13:19.000Z","updated":"2021-06-12T13:04:34.679Z","comments":true,"path":"undefined/ec01d655.html","link":"","permalink":"https://franxhao.top/undefined/ec01d655.html","excerpt":"简单介绍文章主要分享本人的单片机学习过程，包含：课题、代码、程序仿真以及个人向的理解和推荐（不够专业，望理解）。希望能够对大家有帮助。 实验一P1接8个灯，P3.2、 P3.3、 P3.4、P3.5接4个按钮，按下P3.2 P1的8个灯奇亮偶不亮；按下P3.3 P1的8个灯偶量奇不亮；按下P3.4 P1的8个灯流水灯顺着滚动遍；按下P3.5 P1的8个灯流水灯倒着滚动一遍。 编写程序实现以上功能。","text":"简单介绍文章主要分享本人的单片机学习过程，包含：课题、代码、程序仿真以及个人向的理解和推荐（不够专业，望理解）。希望能够对大家有帮助。 实验一P1接8个灯，P3.2、 P3.3、 P3.4、P3.5接4个按钮，按下P3.2 P1的8个灯奇亮偶不亮；按下P3.3 P1的8个灯偶量奇不亮；按下P3.4 P1的8个灯流水灯顺着滚动遍；按下P3.5 P1的8个灯流水灯倒着滚动一遍。 编写程序实现以上功能。 首先根据题目发现使用到的I/O端口为P1和P3，注意8个灯接P1.0-1.7,4个按钮接P3.2-3.5。灯的问题由十六进制代码实现。 代码实现： 123456789101112131415161718192021222324252627282930313233343536#include&lt;reg51.h&gt;void delay(unsigned int time)//延时函数&#123; unsigned int i,j; for(i=0;i&lt;time;i++) for(j=0;j&lt;1000;j++);&#125;void main()&#123; unsigned int y; unsigned int a[8]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f&#125;;//流水灯P1口的值 unsigned int b[8]=&#123;0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe&#125;; while(1) &#123; if(P3==0xfb) //按下P3.2 P1的8个灯奇亮偶不亮 P1=0xaa; else if(P3==0xf7) //按下P3.3 P1的8个灯偶亮奇不亮 P1=0x55; else if(P3==0xef) //按下P3.4 P1的8个灯流水灯顺着滚动一遍 for(y=0;y&lt;8;y++) &#123; P1=a[y]; delay(20); &#125; else if(P3==0xdf) //按下P3.5 P1的8个灯流水灯逆着滚动一遍 for(y=0;y&lt;8;y++) &#123; P1=b[y]; delay(20); &#125; else P1=0xff; &#125;&#125; p.s：此程序还可以进一步简化，关于P3.5可以使用for语句逆循环a数组里的数据，但是要注意的是需要将变量y的无符号型限制去掉才可以使用，否则会出现错误。 仿真演示： 小结 了解I/O端口以及对应的十六进制代码表示；熟悉C语言if-else和for语句，延时函数。 使用到的软件 代码编辑器/IDE：主要用来写C语言的代码，我比较喜欢用的是Notepad++和VS Code。这两个编写和浏览代码比较舒服，学校让我们装的是VC6.0。简单介绍一下我用过的： VC6.0：比较老了，初学者用一下可以，但是不推荐未来使用。我的使用感受是启动慢，字体小，没有编辑辅助功能，有的错误它不会提示，要自己去找。总的来说就是不够智能吧。 Notepad++：优秀的代码编辑器，支持超过50种编程、脚本和标记语言的语法高亮显示，代码可折叠方便查阅整个文档。轻量化的感觉，开启迅速，编写和浏览很舒服。 VS Code：第一次接触它是从搭建博客开始的，之前都是使用Notepad++，至于VC6.0？？？除了刚学C的时候用过，之后再没打开过。同样也是轻量级体验，支持几乎所有主流的开发语言的语法高亮和智能代码补全等。如果需要看大量代码的话这个是很推荐的，看着比较舒服；如果是单片机初学阶段，写的代码不多，个人推荐Notepad++就够了。 SUBLIME TEXT：这款也是因为搭建博客而接触到的编辑器。有付费内容，但是使用免费的不影响体验也没有时间限制，使用感受和VS Code差不多，同样拥有高亮显示和编辑辅助功能。和VS Code看起来我觉得SUBLIME TEXT的代码显示要Q些，看起来比较可爱哈哈哈。 以上就是我使用过的编辑器的简单介绍了，如果想了解得更细致些可以到google和baidu查。我们还学习了Java SE，当时使用的IDE是eclipse，由于这里主要介绍本人单片机课程的内容，代码是用C语言写的，所以就不对eclipse进行介绍了。 Keil 3：用来对代码进行编译和生成.HEX文件。 hex文件格式是可以烧写到单片机中，被单片机执行的一种文件格式。生成hex文件的方式有很多种，可以通过不同的编译器将C程序或者汇编程序编译生成hex,这里用的是Keil。 Proteus：EDA工具仿真软件，用来仿真单片机等器件。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C51单片机","slug":"嵌入式/C51单片机","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/C51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"C51单片机","slug":"C51单片机","permalink":"https://franxhao.top/tags/C51%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"我的第一篇博客","slug":"第一篇","date":"2020-03-31T04:33:08.000Z","updated":"2020-08-17T17:10:32.659Z","comments":true,"path":"undefined/d95d7e09.html","link":"","permalink":"https://franxhao.top/undefined/d95d7e09.html","excerpt":"关于第一篇博客关于我创建这个博客的目的在关于一栏里有简单介绍，接下来这篇文章主要是写一下在我搭建博客过程中的心得吧。 首先本站是我搭建的第三个Hexo博客网站，那另外两个呢？另外两个因为操作过于萌新不满意搭建效果都删掉重来了QAQ。其实这第三个网站我费尽了千辛万苦才成功搭建起来，因为有前两个网站的搭建历史，导致我重新建第三个网站的时候经常出现克隆失败的情况，我当时都懵了，以为我不能再建Hexo博客了，不断地去查找资料寻找解决方案，最后终于在这条 强制清除缓存 指令npm cache clean --force 下让我重新成功搭建起Hexo博客，所以搭建不易，大家要好好爱惜自己辛苦搭建起来的博客网站啊。","text":"关于第一篇博客关于我创建这个博客的目的在关于一栏里有简单介绍，接下来这篇文章主要是写一下在我搭建博客过程中的心得吧。 首先本站是我搭建的第三个Hexo博客网站，那另外两个呢？另外两个因为操作过于萌新不满意搭建效果都删掉重来了QAQ。其实这第三个网站我费尽了千辛万苦才成功搭建起来，因为有前两个网站的搭建历史，导致我重新建第三个网站的时候经常出现克隆失败的情况，我当时都懵了，以为我不能再建Hexo博客了，不断地去查找资料寻找解决方案，最后终于在这条 强制清除缓存 指令npm cache clean --force 下让我重新成功搭建起Hexo博客，所以搭建不易，大家要好好爱惜自己辛苦搭建起来的博客网站啊。 因为我的专业主要在嵌入式开发方向，只接触过C，Java和汇编语言，对JS和网页方面的知识不太了解，所以在搭建和完善本站的过程中出现了很多问题，比如主题、插入图片等问题，经常要花一部分时间去查找解决方案才能解决。在这里不得不说一下，真心想搭建好一个博客是需要花时间下功夫去摸索的，因为没有接触过JS和前端方面的知识做这个更是艰难，我只能尽自己所能把自己的博客做到自己满意的效果。 Hexo博客搭建教程视频推荐首先我搭建的Hexo博客是参考了以下教程视频的，在这里可以给大家分享一下： 使用Mac或者Linux来搭建的话，推荐 CodeSheep 羊哥的视频， 传送门：https://www.bilibili.com/video/BV1Yb411a7ty 使用windows搭建的话，我是看了Master_lisa小姐姐的视频，每一步都特别详细（声音也很好听 /滑稽），传送门：https://www.bilibili.com/video/BV1A4411G7SF 聊一聊关于我的博客的发展 会写一下关于现在专业知识学习时遇到的问题，可能会写一下学习过程中的心得吧。 有时间的话会写一下关于Hexo和Hugo博客搭建时遇到的问题，可能会有点教程内容，当然教程部分会用别人的来做参考，我会放出参考链接。 还有什么的话我会后续更新的… 我在Hexo和Hugo之间的选择大家都知道Hexo是基于Nodejs，Hugo是基于Go语言编写的。Hexo和Hugo之间各有优缺点，Hexo优点在于使用的人多，主题和插件多，正因如此，Hexo可以做很多美化工作，出现问题的话网上的解决方案会比较多，问题容易解决。但是它有个缺点，就是当文章数多了之后生成静态的速度会很慢，这个问题其实挺难受的。 而Hugo恰恰相反，主题和插件没有Hexo多，相应的教程就比较少。当然如果博客主要用途是用在写文章上，对主题美化要求不是特别高的话，这个问题是可以忽略不计的。其次，Hugo最大的优点就是生成静态的速度非常快，可能Hexo需要几分钟，而Hugo只需要几秒钟。 对于Hexo和Hugo之间的选择因人而异，在正式运用博客上我是想选择Hugo的，但是现在使用的是Hexo，这是因为一开始我接触到的教程是Hexo的，发现使用的人比较多我就也跟着做了，还有一点就是我对博客搭建方面的知识还不够充足，常常出现很多问题，查找解决方案的时候很方便。我也搭有一个Hugo的博客，本来是打算用它的，但是在主题方面出现了很多问题，去查问题也没查出来，所以只能先用着Hexo了。因为做博客确实花费了大量时间，后期有时间我慢慢去摸索吧。 搭建个人博客的好处想必学习计算机方向的同学都知道搭建个人博客对未来找工作面试的时候会有很大的加分。还有我觉得可以对自己学习的知识进行总结和记录，方便今后的复习。在搭建博客的过程中查找问题解决方案时肯定会接触到别人的博客，别人的博客里面或许会有那么一两篇对你有用的干货，同时还可以接触到你没接触过的知识，不断拓展自己的知识层，俗话说：“技多不压身”，多了解一点或许在某个时候会对自己有帮助哦。 小结第一篇写得太多了…… 今后我会不断完善这个博客的，接下来就请期待我不定期的更新吧哈哈哈","categories":[{"name":"博客","slug":"博客","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"踩坑记录","slug":"博客/踩坑记录","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://franxhao.top/tags/%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"嵌入式/STM32","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/"},{"name":"博客","slug":"博客","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"博客/Hexo","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/Hexo/"},{"name":"C51单片机","slug":"嵌入式/C51单片机","permalink":"https://franxhao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/C51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"系统","slug":"系统","permalink":"https://franxhao.top/categories/%E7%B3%BB%E7%BB%9F/"},{"name":"Hexo","slug":"Hexo","permalink":"https://franxhao.top/categories/Hexo/"},{"name":"踩坑记录","slug":"Hexo/踩坑记录","permalink":"https://franxhao.top/categories/Hexo/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"Typecho","slug":"博客/Typecho","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/Typecho/"},{"name":"Pi","slug":"Pi","permalink":"https://franxhao.top/categories/Pi/"},{"name":"树莓派","slug":"Pi/树莓派","permalink":"https://franxhao.top/categories/Pi/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"踩坑记录","slug":"博客/踩坑记录","permalink":"https://franxhao.top/categories/%E5%8D%9A%E5%AE%A2/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://franxhao.top/tags/STM32/"},{"name":"Hexo","slug":"Hexo","permalink":"https://franxhao.top/tags/Hexo/"},{"name":"C51单片机","slug":"C51单片机","permalink":"https://franxhao.top/tags/C51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"frp","slug":"frp","permalink":"https://franxhao.top/tags/frp/"},{"name":"Typecho","slug":"Typecho","permalink":"https://franxhao.top/tags/Typecho/"},{"name":"RSSHub","slug":"RSSHub","permalink":"https://franxhao.top/tags/RSSHub/"},{"name":"树莓派","slug":"树莓派","permalink":"https://franxhao.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"博客","slug":"博客","permalink":"https://franxhao.top/tags/%E5%8D%9A%E5%AE%A2/"}]}