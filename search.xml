<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【嵌入式STM32】系列文章汇总</title>
    <url>/undefined/64afecd0.html</url>
    <content><![CDATA[<h1 id="嵌入式STM32——实验系列文章汇总传送门"><a href="#嵌入式STM32——实验系列文章汇总传送门" class="headerlink" title="嵌入式STM32——实验系列文章汇总传送门"></a>嵌入式STM32——实验系列文章汇总传送门</h1><ul>
<li><p><strong><a href="/undefined/fc8a844.html" title="第一篇：新建库函数版和寄存器版工程模板">第一篇：新建库函数版和寄存器版工程模板</a></strong> </p>
</li>
<li><p><strong><a href="/undefined/35ffacf0.html" title="第二篇：跑马灯实验">第二篇：跑马灯实验</a></strong> </p>
</li>
<li><p><strong><a href="/undefined/44c24675.html" title="第三篇：按键亮灯实验">第三篇：按键亮灯实验</a></strong> </p>
</li>
<li><p><strong><a href="/undefined/d0886a84.html" title="第四篇：串口实验">第四篇：串口实验</a></strong> </p>
</li>
<li><p><strong><a href="/undefined/5817d212.html" title="第五篇：外部中断实验">第五篇：外部中断实验</a></strong> </p>
</li>
<li><p><strong><a href="/undefined/c0feab90.html" title="第六篇：定时器中断实验">第六篇：定时器中断实验</a></strong> </p>
</li>
<li><p><strong><a href="/undefined/d8eae319.html" title="第七篇：ADC实验">第七篇：ADC实验</a></strong> </p>
</li>
</ul>
  <a id="more"></a>

<h1 id="STM32中文参考手册"><a href="#STM32中文参考手册" class="headerlink" title="STM32中文参考手册"></a>STM32中文参考手册</h1><p>网盘下载：<a href="https://wwr.lanzoui.com/i0haoq50u3e" target="_blank" rel="noopener">STM32中文参考手册_V10.pdf</a>    密码：axgt</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>【嵌入式STM32】（七）ADC实验</title>
    <url>/undefined/d8eae319.html</url>
    <content><![CDATA[<h1 id="0-实验要求"><a href="#0-实验要求" class="headerlink" title="0. 实验要求"></a>0. 实验要求</h1><p>掌握库函数版的<strong>ADC实验</strong>（寄存器版为自学内容）</p>
<p>要求使用 ADC2，通道 5，连续转换模式，时钟频率 9M，采样时间为 13.5 周期， ADC 数据左对齐，采样 5 次取平均值，显示的值取小数点后 2 位</p>
<p><em>（注：文章仅贴出修改部分代码，详细原码请下载资料包查看）</em></p>
<a id="more"></a>

<h1 id="1-库函数版"><a href="#1-库函数版" class="headerlink" title="1. 库函数版"></a>1. 库函数版</h1><p><strong>(1). adc.h：</strong>定义 ADC 初始化函数，声明 Get_Adc 和 Get_Adc_Average 两个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ADC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ADC_H	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Adc_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">u16  <span class="title">Get_Adc</span><span class="params">(u8 ch)</span></span>; </span><br><span class="line"><span class="function">u16 <span class="title">Get_Adc_Average</span><span class="params">(u8 ch,u8 times)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>(2). adc.c：</strong></p>
<ul>
<li>初始化 ADC2，开启通道 5，设置连续转换模式，时钟频率 9M， ADC 数据左对齐</li>
<li>获取 ADC 值和平均值，设置采样时间为 13.5 周期</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化ADC2</span></span><br><span class="line"><span class="comment">//开启通道5															   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Adc_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">	ADC_InitTypeDef ADC_InitStructure; </span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_ADC2, ENABLE ); <span class="comment">//使能ADC2通道时钟</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//PA1 作为模拟通过输入引脚</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">//通道5</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; <span class="comment">//模拟输入引脚  设置工作模式:模拟输入</span></span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);	</span><br><span class="line">	</span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div8); <span class="comment">//设置ADC分频因子8 72M/8=9M,ADC最大时间不能超过14M</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ADC_DeInit(ADC2); <span class="comment">//复位ADC2,将外设 ADC2 的全部寄存器重设为缺省值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化ADC参数</span></span><br><span class="line">	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;	<span class="comment">//ADC工作模式:ADC1和ADC2工作在独立模式</span></span><br><span class="line">	ADC_InitStructure.ADC_ScanConvMode = DISABLE; <span class="comment">//模数转换工作在单通道模式  不用扫描模式   单通道模式:DISABLE  多通道模式：ENABLE</span></span><br><span class="line">	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; <span class="comment">//模数转换工作在连续转换模式    单次转换模式：DISABLE  连续转换模式：ENABLE</span></span><br><span class="line">	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	<span class="comment">//转换由软件而不是外部触发启动</span></span><br><span class="line">	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Left; <span class="comment">//ADC数据左对齐</span></span><br><span class="line">	ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;	<span class="comment">//顺序进行规则转换的ADC通道的数目</span></span><br><span class="line">	ADC_Init(ADC2, &amp;ADC_InitStructure);	<span class="comment">//根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器 </span></span><br><span class="line">  </span><br><span class="line">	ADC_Cmd(ADC2, ENABLE); <span class="comment">//使能指定的ADC2</span></span><br><span class="line">	</span><br><span class="line">	ADC_ResetCalibration(ADC2);	<span class="comment">//使能复位校准  </span></span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC2));	<span class="comment">//等待复位校准结束</span></span><br><span class="line">	</span><br><span class="line">	ADC_StartCalibration(ADC2); <span class="comment">//开启AD校准</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC2)); <span class="comment">//等待校准结束</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//	ADC_SoftwareStartConvCmd(ADC2, ENABLE); //使能指定的ADC2的软件转换启动功能</span></span><br><span class="line"></span><br><span class="line">&#125;				  </span><br><span class="line"><span class="comment">//获得ADC值</span></span><br><span class="line"><span class="comment">//ch:通道值 0~3</span></span><br><span class="line"><span class="function">u16 <span class="title">Get_Adc</span><span class="params">(u8 ch)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//设置指定ADC的规则组通道，一个序列，采样时间</span></span><br><span class="line">	ADC_RegularChannelConfig(ADC2, ch, <span class="number">1</span>, ADC_SampleTime_13Cycles5 ); <span class="comment">//ADC2,ADC通道,采样时间为13.5周期	  			    </span></span><br><span class="line">  </span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC2, ENABLE); <span class="comment">//使能指定的ADC2的软件转换启动功能	</span></span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">while</span>(!ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC )); <span class="comment">//等待转换结束</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC2); <span class="comment">//返回最近一次ADC2规则组的转换结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">u16 <span class="title">Get_Adc_Average</span><span class="params">(u8 ch,u8 times)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 temp_val=<span class="number">0</span>;</span><br><span class="line">	u8 t;</span><br><span class="line">	<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;times;t++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp_val+=Get_Adc(ch);</span><br><span class="line">		delay_ms(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp_val/times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3). main.c：</strong>主要修改 while 循环部分，取 ADC 平均值参数设置为通道 5 和采样 5 次平均值；在 temp*=100 中，设置为 100 是为了取小数后两位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    adcx=Get_Adc_Average(ADC_Channel_5,<span class="number">5</span>); <span class="comment">//通道5，采样5次取平均值</span></span><br><span class="line">    LCD_ShowxNum(<span class="number">156</span>,<span class="number">130</span>,adcx,<span class="number">4</span>,<span class="number">16</span>,<span class="number">0</span>); <span class="comment">//显示ADC的值</span></span><br><span class="line">    temp=(<span class="keyword">float</span>)adcx*(<span class="number">3.3</span>/<span class="number">4096</span>);</span><br><span class="line">    adcx=temp;</span><br><span class="line">    LCD_ShowxNum(<span class="number">156</span>,<span class="number">150</span>,adcx,<span class="number">1</span>,<span class="number">16</span>,<span class="number">0</span>); <span class="comment">//显示电压值</span></span><br><span class="line">    temp-=adcx;</span><br><span class="line">    temp*=<span class="number">100</span>; <span class="comment">//1000取小数点后3位，100取后2位</span></span><br><span class="line">    LCD_ShowxNum(<span class="number">172</span>,<span class="number">150</span>,temp,<span class="number">3</span>,<span class="number">16</span>,<span class="number">0X80</span>);</span><br><span class="line">    LED0=!LED0;</span><br><span class="line">    delay_ms(<span class="number">250</span>);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3.  参考资料"></a>3.  参考资料</h1><p>ADC实验原码下载：</p>
<ul>
<li>网盘下载：<a href="https://wwr.lanzoui.com/iZMLbq6lbod" target="_blank" rel="noopener">ADC实验.zip</a>    密码：ey1e</li>
<li>内容包含：<ul>
<li>寄存器和库函数模板初始原码</li>
<li>按实验要求修改后的原码</li>
</ul>
</li>
</ul>
<p>嵌入式STM32学习视频：</p>
<ul>
<li>字母站传送门：<a href="https://www.bilibili.com/video/BV1kx411k7JT" target="_blank" rel="noopener">【正点原子】STM32开发板实验教程</a></li>
</ul>
<h1 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h1><p>这是【嵌入式STM32】系列文章的最后一篇文章了，在这里做一个结束总结</p>
<p>关于【嵌入式STM32】是作者大三第二学期的课程，其内容是以实验课内容为主来撰写的。文章部分内容不多，所以只靠阅读文章是不够的，需要自行将提供的原码资料下载出来，通过Keil 5 来查看、对比和动手修改才能学到相应的知识</p>
<p>最后希望能对读者学习有帮助，祝考运昌盛！</p>
<div class="note info">
            <p>所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途<br>想看更多有关【嵌入式STM32】的文章可以前往：<strong><a href="/undefined/64afecd0.html" title="【嵌入式STM32】文章汇总">【嵌入式STM32】文章汇总</a></strong> </p>
          </div>



]]></content>
      <categories>
        <category>嵌入式</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>【嵌入式STM32】（六）定时器中断实验</title>
    <url>/undefined/c0feab90.html</url>
    <content><![CDATA[<h1 id="0-实验要求"><a href="#0-实验要求" class="headerlink" title="0. 实验要求"></a>0. 实验要求</h1><p>掌握寄存器版和库函数版的<strong>定时器中断实验</strong></p>
<p>本次实验以跑马灯为基础，<u>LED灯</u>接端口 PC8-PC11并依次点亮，点亮时间间隔2s。使用定时器 2 中断、向下计数、2s 产生 1 次中断（溢出）；中断优先级分组为组 3，抢占优先级 4 级，响应优先级 1 级</p>
<p><em>（注：文章仅贴出修改部分代码，详细原码请下载资料包查看）</em></p>
<a id="more"></a>

<h1 id="1-寄存器版"><a href="#1-寄存器版" class="headerlink" title="1. 寄存器版"></a>1. 寄存器版</h1><p><strong>(1). timer.c：</strong></p>
<ul>
<li>初始化定时器 2 中断：先使能 TIM2 时钟，然后给 TIM2 设定计数器 自动重装载值 arr 和预分频器 psc，通过 DIER 寄存器允许更新中断，CR1 寄存器使能定时器 2，设置向下计数，即位 0 和位 4 置 1：00010001=0x11，最后在MY_NVIC_Init 中设置中断优先级分组为组 3，抢占优先级 4 级，响应优先级为1</li>
<li>定时器 2 中断服务函数：为实现跑马灯，在中断服务程序中使用 count 计数进行判断来控制 LED 的亮灭，每次中断服务结束后都需要清除中断标志位，保证下次中断计时能够从 0 开始，正常运行</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定时器2中断服务程序	 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM2_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; 		    		  			    </span><br><span class="line">	<span class="keyword">if</span>(TIM2-&gt;SR&amp;<span class="number">0X0001</span>)<span class="comment">//溢出中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">			LED0 = <span class="number">0</span>;</span><br><span class="line">			LED1 = <span class="number">1</span>;</span><br><span class="line">			LED2 = <span class="number">1</span>;</span><br><span class="line">			LED3 = <span class="number">1</span>;</span><br><span class="line">			count+=<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">			LED0 = <span class="number">1</span>;</span><br><span class="line">			LED1 = <span class="number">0</span>;</span><br><span class="line">			LED2 = <span class="number">1</span>;</span><br><span class="line">			LED3 = <span class="number">1</span>;</span><br><span class="line">			count+=<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">2</span>)&#123;</span><br><span class="line">			LED0 = <span class="number">1</span>;</span><br><span class="line">			LED1 = <span class="number">1</span>;</span><br><span class="line">			LED2 = <span class="number">0</span>;</span><br><span class="line">			LED3 = <span class="number">1</span>;</span><br><span class="line">			count+=<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">3</span>)&#123;</span><br><span class="line">			LED0 = <span class="number">1</span>;</span><br><span class="line">			LED1 = <span class="number">1</span>;</span><br><span class="line">			LED2 = <span class="number">1</span>;</span><br><span class="line">			LED3 = <span class="number">0</span>;</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;			   </span><br><span class="line">	TIM2-&gt;SR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);<span class="comment">//清除中断标志位 	    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用定时器中断初始化</span></span><br><span class="line"><span class="comment">//这里时钟选择为APB1的2倍，而APB1为36M</span></span><br><span class="line"><span class="comment">//arr：自动重装值。</span></span><br><span class="line"><span class="comment">//psc：时钟预分频数</span></span><br><span class="line"><span class="comment">//这里使用的是定时器2!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM2_Int_Init</span><span class="params">(u16 arr,u16 psc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC-&gt;APB1ENR|=<span class="number">1</span>&lt;&lt;<span class="number">0</span>;	<span class="comment">//TIM2时钟使能    </span></span><br><span class="line"> 	TIM2-&gt;ARR=arr; <span class="comment">//设定计数器自动重装值 </span></span><br><span class="line">	TIM2-&gt;PSC=psc; <span class="comment">//预分频器设置</span></span><br><span class="line">	TIM2-&gt;DIER|=<span class="number">1</span>&lt;&lt;<span class="number">0</span>; <span class="comment">//允许更新中断				</span></span><br><span class="line">	TIM2-&gt;CR1|=<span class="number">0x11</span>; <span class="comment">//使能定时器2,向下计数,2s产生1次中断（溢出） 00010001</span></span><br><span class="line">  	MY_NVIC_Init(<span class="number">4</span>,<span class="number">1</span>,TIM2_IRQn,<span class="number">3</span>); <span class="comment">//抢占4，子优先级1，组3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2). main.c：</strong>主函数。加入时钟 2 中断初始化函数 TIM2_Int_Init(19999,7199); 因为 APB1 的分频系数是 2，所以 APB1 为 36M，由公式 Tout=（ARR+1)(PSC+1)/Tclk 可知，为了让预分频系数能整除真正时钟 Tclk，需要给 PSC 设置为 7199，根据要求 2s 后产生 1 次中断（时钟溢出），即跑马灯闪烁时间间隔为 2s，则将 ARR 设置为 19999 即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;		 </span><br><span class="line">	Stm32_Clock_Init(<span class="number">9</span>); <span class="comment">//系统时钟设置</span></span><br><span class="line">	delay_init(<span class="number">72</span>); <span class="comment">//延时初始化</span></span><br><span class="line">	uart_init(<span class="number">72</span>,<span class="number">9600</span>); <span class="comment">//串口初始化 </span></span><br><span class="line">	LED_Init(); <span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">	TIM2_Int_Init(<span class="number">19999</span>,<span class="number">7199</span>); <span class="comment">//10Khz的计数频率，计数到2000为2s  	</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-库函数版"><a href="#2-库函数版" class="headerlink" title="2. 库函数版"></a>2. 库函数版</h1><p><strong>(1). timer.c：</strong>首先对定时器 2 进行时钟使能，然后设置自动重装载值和预分频值， 将 TIM2 设置为向下计数模式，配置好中断优先级后使能 TIM2 中断，最后开始中断服务函数，执行跑马灯程序，执行完毕后清除中断标志位，以便下次中断的正常进行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通用定时器中断初始化</span></span><br><span class="line"><span class="comment">//这里时钟选择为APB1的2倍，而APB1为36M</span></span><br><span class="line"><span class="comment">//arr：自动重装值。</span></span><br><span class="line"><span class="comment">//psc：时钟预分频数</span></span><br><span class="line"><span class="comment">//这里使用的是定时器2!</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM2_Int_Init</span><span class="params">(u16 arr,u16 psc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); <span class="comment">//时钟使能</span></span><br><span class="line"></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = arr; <span class="comment">//设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 计数到20000为2000ms</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler =psc; <span class="comment">//设置用来作为TIMx时钟频率除数的预分频值  10Khz的计数频率  </span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; <span class="comment">//设置时钟分割:TDTS = Tck_tim</span></span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Down; <span class="comment">//TIM向下计数模式</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure); <span class="comment">//根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位</span></span><br><span class="line"> </span><br><span class="line">	TIM_ITConfig( <span class="comment">//使能或者失能指定的TIM中断</span></span><br><span class="line">		TIM2, <span class="comment">//TIM2</span></span><br><span class="line">		TIM_IT_Update ,</span><br><span class="line">		ENABLE <span class="comment">//使能</span></span><br><span class="line">		);</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; <span class="comment">//TIM2中断</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">4</span>; <span class="comment">//抢占优先级4级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>; <span class="comment">//响应优先级1级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//IRQ通道被使能</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure); <span class="comment">//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</span></span><br><span class="line"></span><br><span class="line">	TIM_Cmd(TIM2, ENABLE); <span class="comment">//使能TIMx外设				 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIM2中断服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM2_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET) <span class="comment">//检查指定的TIM中断发生与否:TIM 中断源 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">				LED0 = <span class="number">0</span>;</span><br><span class="line">				LED1 = <span class="number">1</span>;</span><br><span class="line">				LED2 = <span class="number">1</span>;</span><br><span class="line">				LED3 = <span class="number">1</span>;</span><br><span class="line">				count+=<span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">				LED0 = <span class="number">1</span>;</span><br><span class="line">				LED1 = <span class="number">0</span>;</span><br><span class="line">				LED2 = <span class="number">1</span>;</span><br><span class="line">				LED3 = <span class="number">1</span>;</span><br><span class="line">				count+=<span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">2</span>)&#123;</span><br><span class="line">				LED0 = <span class="number">1</span>;</span><br><span class="line">				LED1 = <span class="number">1</span>;</span><br><span class="line">				LED2 = <span class="number">0</span>;</span><br><span class="line">				LED3 = <span class="number">1</span>;</span><br><span class="line">				count+=<span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">3</span>)&#123;</span><br><span class="line">				LED0 = <span class="number">1</span>;</span><br><span class="line">				LED1 = <span class="number">1</span>;</span><br><span class="line">				LED2 = <span class="number">1</span>;</span><br><span class="line">				LED3 = <span class="number">0</span>;</span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			TIM_ClearITPendingBit(TIM2, TIM_IT_Update  ); <span class="comment">//清除TIM2的中断待处理位:TIM 中断源 </span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2). main.c：</strong>在主函数中设置中断优先级分组为组 3。加入时钟 2 中断初始化函数 TIM2_Int_Init(19999,7199)。（其余解释与寄存器版主函数相同）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    delay_init(); <span class="comment">//延时函数初始化</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3); <span class="comment">//设置中断优先级分组3</span></span><br><span class="line">    LED_Init(); <span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">    TIM2_Int_Init(<span class="number">19999</span>,<span class="number">7199</span>); <span class="comment">//10Khz的计数频率，计数到20000为2000ms  </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3.  参考资料"></a>3.  参考资料</h1><p>定时器中断实验原码下载：</p>
<ul>
<li>网盘下载：<a href="https://wwr.lanzoui.com/ivZWcq6khsh" target="_blank" rel="noopener">定时器中断实验.zip</a>    密码：8jsp</li>
<li>内容包含：<ul>
<li>寄存器和库函数模板初始原码</li>
<li>按实验要求修改后的原码</li>
</ul>
</li>
</ul>
<p>嵌入式STM32学习视频：</p>
<ul>
<li>字母站传送门：<a href="https://www.bilibili.com/video/BV1kx411k7JT" target="_blank" rel="noopener">【正点原子】STM32开发板实验教程</a></li>
</ul>
<div class="note info">
            <p>所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途<br>想看更多有关【嵌入式STM32】的文章可以前往：<strong><a href="/undefined/64afecd0.html" title="【嵌入式STM32】文章汇总">【嵌入式STM32】文章汇总</a></strong> </p>
          </div>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>【嵌入式STM32】（五）外部中断实验</title>
    <url>/undefined/5817d212.html</url>
    <content><![CDATA[<h1 id="0-实验要求"><a href="#0-实验要求" class="headerlink" title="0. 实验要求"></a>0. 实验要求</h1><p>掌握寄存器版和库函数版的<strong>外部中断实验</strong></p>
<p>本次实验以按键亮灯为基础，<u>按键</u>接端口 PC0-PC3，<u>LED灯</u>接端口 PC8-PC11。中断优先级分组组 2，抢占优先级 2 级，响应优先级分别为 3102</p>
<p><em>（注：文章仅贴出修改部分代码，详细原码请下载资料包查看）</em></p>
<a id="more"></a>

<h1 id="1-寄存器版"><a href="#1-寄存器版" class="headerlink" title="1. 寄存器版"></a>1. 寄存器版</h1><p><strong>exit.c：</strong>设置外部中断服务，初始化外部中断程序，PC0-PC3 为中断输入，中 断优先级分组为组 2，抢占优先级 2 级，响应优先级 3102</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部中断0服务程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_ms(<span class="number">10</span>);	<span class="comment">//消抖</span></span><br><span class="line">	LED0=!LED0;	</span><br><span class="line">	EXTI-&gt;PR=<span class="number">1</span>&lt;&lt;<span class="number">0</span>;  <span class="comment">//清除LINE0上的中断标志位  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部中断1服务程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_ms(<span class="number">10</span>);	<span class="comment">//消抖</span></span><br><span class="line">	LED1=!LED1;	</span><br><span class="line">	EXTI-&gt;PR=<span class="number">1</span>&lt;&lt;<span class="number">1</span>;  <span class="comment">//清除LINE1上的中断标志位  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部中断2服务程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI2_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_ms(<span class="number">10</span>);	<span class="comment">//消抖</span></span><br><span class="line">	LED2=!LED2;	</span><br><span class="line">	EXTI-&gt;PR=<span class="number">1</span>&lt;&lt;<span class="number">2</span>;  <span class="comment">//清除LINE2上的中断标志位  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部中断3服务程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI3_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_ms(<span class="number">10</span>);	<span class="comment">//消抖</span></span><br><span class="line">	LED3=!LED3;	</span><br><span class="line">	EXTI-&gt;PR=<span class="number">1</span>&lt;&lt;<span class="number">3</span>;  <span class="comment">//清除LINE3上的中断标志位  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部中断初始化程序</span></span><br><span class="line"><span class="comment">//初始化PC0-PC3为中断输入.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KEY_Init();</span><br><span class="line">	Ex_NVIC_Config(GPIO_C,<span class="number">0</span>,FTIR); 	<span class="comment">//下降沿触发(上升沿触发：RTIR)</span></span><br><span class="line">	Ex_NVIC_Config(GPIO_C,<span class="number">1</span>,FTIR);	<span class="comment">//下降沿触发</span></span><br><span class="line">	Ex_NVIC_Config(GPIO_C,<span class="number">2</span>,FTIR);	<span class="comment">//下降沿触发</span></span><br><span class="line">	Ex_NVIC_Config(GPIO_C,<span class="number">3</span>,FTIR);	<span class="comment">//下降沿触发</span></span><br><span class="line"></span><br><span class="line">	MY_NVIC_Init(<span class="number">2</span>,<span class="number">3</span>,EXTI0_IRQn,<span class="number">2</span>);	<span class="comment">//抢占2，子优先级3，组2</span></span><br><span class="line">	MY_NVIC_Init(<span class="number">2</span>,<span class="number">1</span>,EXTI1_IRQn,<span class="number">2</span>);	<span class="comment">//抢占2，子优先级1，组2</span></span><br><span class="line">	MY_NVIC_Init(<span class="number">2</span>,<span class="number">0</span>,EXTI2_IRQn,<span class="number">2</span>);	<span class="comment">//抢占2，子优先级0，组2	</span></span><br><span class="line">	MY_NVIC_Init(<span class="number">2</span>,<span class="number">2</span>,EXTI3_IRQn,<span class="number">2</span>);	<span class="comment">//抢占2，子优先级2，组2	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-库函数版"><a href="#2-库函数版" class="headerlink" title="2. 库函数版"></a>2. 库函数版</h1><p><strong>exti.c：</strong>外部中断初始化函数。使能 AFIO 时钟，设置中断模式且下降沿触发，根据 EXTI_InitStruct 中指定的参数初始化外设 EXTI 寄存器；使能按键所在 的外部中断通道，抢占优先级 2 级、响应优先级 3102，开启使能后根据 NVIC_InitStruct 中指定的参数初始化外设 NVIC 寄存器。最后开启外部中断服务，服务最后清除 EXTIx 线路挂起位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部中断初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTIX_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); <span class="comment">//外部中断，需要使能AFIO时钟</span></span><br><span class="line"></span><br><span class="line">    KEY_Init();<span class="comment">//初始化按键对应io模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GPIOC.0 中断线以及中断初始化配置</span></span><br><span class="line">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource0);</span><br><span class="line"></span><br><span class="line">    EXTI_InitStructure.EXTI_Line = EXTI_Line0;</span><br><span class="line">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//下降沿触发</span></span><br><span class="line">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">    EXTI_Init(&amp;EXTI_InitStructure); <span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GPIOC.1 中断线以及中断初始化配置</span></span><br><span class="line">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource1);</span><br><span class="line"></span><br><span class="line">    EXTI_InitStructure.EXTI_Line = EXTI_Line1;</span><br><span class="line">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//下降沿触发</span></span><br><span class="line">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">    EXTI_Init(&amp;EXTI_InitStructure); <span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GPIOC.2 中断线以及中断初始化配置</span></span><br><span class="line">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource2);</span><br><span class="line"></span><br><span class="line">    EXTI_InitStructure.EXTI_Line = EXTI_Line2;</span><br><span class="line">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//下降沿触发</span></span><br><span class="line">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">    EXTI_Init(&amp;EXTI_InitStructure); <span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GPIOC.3 中断线以及中断初始化配置</span></span><br><span class="line">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource3);</span><br><span class="line"></span><br><span class="line">    EXTI_InitStructure.EXTI_Line = EXTI_Line3;</span><br><span class="line">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//下降沿触发</span></span><br><span class="line">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">    EXTI_Init(&amp;EXTI_InitStructure); <span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; <span class="comment">//使能按键所在的外部中断通道</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0x02</span>; <span class="comment">//抢占优先级2</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0x03</span>; <span class="comment">//子优先级3</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//使能外部中断通道</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure); <span class="comment">//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</span></span><br><span class="line"></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn; <span class="comment">//使能按键所在的外部中断通道</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0x02</span>; <span class="comment">//抢占优先级2</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0x01</span>; <span class="comment">//子优先级1</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//使能外部中断通道</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure); <span class="comment">//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</span></span><br><span class="line"></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn; <span class="comment">//使能按键所在的外部中断通道</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0x02</span>; <span class="comment">//抢占优先级2</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0x00</span>; <span class="comment">//子优先级0</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//使能外部中断通道</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure); <span class="comment">//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</span></span><br><span class="line"></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn; <span class="comment">//使能按键所在的外部中断通道</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0x02</span>; <span class="comment">//抢占优先级2</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0x02</span>; <span class="comment">//子优先级2</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//使能外部中断通道</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure); <span class="comment">//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    delay_ms(<span class="number">10</span>);    <span class="comment">//消抖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(KEY0 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED0 = !LED0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EXTI_ClearITPendingBit(EXTI_Line0);  <span class="comment">//清除EXTI0线路挂起位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    delay_ms(<span class="number">10</span>);    <span class="comment">//消抖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        LED1 = !LED1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EXTI_ClearITPendingBit(EXTI_Line1);  <span class="comment">//清除EXTI1线路挂起位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI2_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    delay_ms(<span class="number">10</span>);    <span class="comment">//消抖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(KEY2 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED2 = !LED2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EXTI_ClearITPendingBit(EXTI_Line2);  <span class="comment">//清除EXTI2线路挂起位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI3_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    delay_ms(<span class="number">10</span>);    <span class="comment">//消抖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(KEY3 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED3 = !LED3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EXTI_ClearITPendingBit(EXTI_Line3);  <span class="comment">//清除EXTI3线路挂起位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main函数</code>中添加 <strong>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</strong> 来设置中断优先级分组为组2</p>
<h1 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3.  参考资料"></a>3.  参考资料</h1><p>外部中断实验原码下载：</p>
<ul>
<li>网盘下载：<a href="https://wwr.lanzoui.com/i8kvlq83wsh" target="_blank" rel="noopener">外部中断实验.zip</a>    密码：ac9y</li>
<li>内容包含：<ul>
<li>寄存器和库函数模板初始原码</li>
<li>按实验要求修改后的原码</li>
</ul>
</li>
</ul>
<p>嵌入式STM32学习视频：</p>
<ul>
<li>字母站传送门：<a href="https://www.bilibili.com/video/BV1kx411k7JT" target="_blank" rel="noopener">【正点原子】STM32开发板实验教程</a></li>
</ul>
<div class="note info">
            <p>所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途<br>想看更多有关【嵌入式STM32】的文章可以前往：<strong><a href="/undefined/64afecd0.html" title="【嵌入式STM32】文章汇总">【嵌入式STM32】文章汇总</a></strong> </p>
          </div>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>【嵌入式STM32】（四）串口实验</title>
    <url>/undefined/d0886a84.html</url>
    <content><![CDATA[<h1 id="0-实验要求"><a href="#0-实验要求" class="headerlink" title="0. 实验要求"></a>0. 实验要求</h1><p>掌握寄存器版和库函数版的<strong>串口实验</strong></p>
<p>使用寄存器和库函数模板分别做<strong>串口1</strong>通信和<strong>串口5</strong>通信实验，其中寄存器和库函数要求如下：</p>
<ul>
<li>寄存器要求：波特率为 115200，设置1位停止位、1位奇数校验位，开启接受中断。发送端推挽复用输出，速度为 10MHz，接收端浮空输入。使用串口助手调试，并能够对代码进行解释，理解中断服务逻辑</li>
<li>库函数要求：波特率为 115200，设置 0.5 位停止位、1位偶数校验位，开启接受中断。发送端推挽复用输出，速度 10MHz；接收端下拉输入。中断优先级组 3，抢占优先级 2 级，响应优先级 1 级</li>
</ul>
<a id="more"></a>

<h2 id="0-1-前期准备"><a href="#0-1-前期准备" class="headerlink" title="0.1 前期准备"></a>0.1 前期准备</h2><ol>
<li>串口 1 对应串口时钟 RCC 是 APB2ENR，串口 2-5 对应串口时钟 RCC 是 APB1ENR</li>
<li>串口 1→pclk2（72M）、串口 2-5 →pclk1（36M）</li>
<li>串口 1 接收端（RXD）→PA10、发送端（TXD）→PA9</li>
<li>串口 5 接收端（RXD）→PD2、发送端（TXD）→PC12</li>
<li>在<strong>寄存器</strong>配置中，停止位(STOP bits)需要用到 USART_CR2 寄存器。CR2寄存器中使用位13:12这2位来设置停止位的位数，根据参考手册停止位设置如下：<ul>
<li>00：1个停止位（若未设置CR2却发现实验成功，是因为未设置寄存器会默认置0，即1个停止位）</li>
<li>01：0.5个停止位</li>
<li>10：2个停止位</li>
<li>11：1.5个停止位</li>
<li>注：<code>UART4</code>和<code>UART5</code>不能用0.5停止位和1.5停止位</li>
</ul>
</li>
</ol>
<h1 id="1-串口1通信"><a href="#1-串口1通信" class="headerlink" title="1. 串口1通信"></a>1. 串口1通信</h1><h2 id="1-1-寄存器版"><a href="#1-1-寄存器版" class="headerlink" title="1.1 寄存器版"></a>1.1 寄存器版</h2><p><strong>(1). usart.h：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART_REC_LEN  			200  	<span class="comment">//定义最大接收字节数 200</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EN_USART1_RX 			1	<span class="comment">//使能（1）/禁止（0）串口1接收</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 </span></span><br><span class="line"><span class="keyword">extern</span> u8  USART_RX_BUF[USART_REC_LEN];</span><br><span class="line"><span class="keyword">extern</span> u16 USART_RX_STA; <span class="comment">//接收状态标记	</span></span><br><span class="line"><span class="comment">//如果想串口中断接收，请不要注释以下宏定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(u32 pclk2,u32 bound)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>(2). usart.c：</strong>修改 IO 口使能时钟和功能参数<em>（仅展示修改部分代码，详细原码请下载资料包查看）</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PA9-PA10  串口1</span></span><br><span class="line"><span class="comment">//初始化IO</span></span><br><span class="line"><span class="comment">//pclk2:PCLK2时钟频率(72Mhz)</span></span><br><span class="line"><span class="comment">//bound:波特率 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(u32 pclk2,u32 bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;  	 </span><br><span class="line">	<span class="keyword">float</span> temp;</span><br><span class="line">	u16 mantissa;</span><br><span class="line">	u16 fraction;	   </span><br><span class="line">	temp=(<span class="keyword">float</span>)(pclk2*<span class="number">1000000</span>)/(bound*<span class="number">16</span>); <span class="comment">//得到USARTDIV</span></span><br><span class="line">	mantissa=temp; <span class="comment">//得到整数部分</span></span><br><span class="line">	fraction=(temp-mantissa)*<span class="number">16</span>; <span class="comment">//得到小数部分	 </span></span><br><span class="line">	mantissa&lt;&lt;=<span class="number">4</span>;</span><br><span class="line">	mantissa+=fraction; </span><br><span class="line">	RCC-&gt;APB2ENR|=<span class="number">1</span>&lt;&lt;<span class="number">2</span>; <span class="comment">//使能PORTA口时钟  </span></span><br><span class="line">	RCC-&gt;APB2ENR|=<span class="number">1</span>&lt;&lt;<span class="number">14</span>; <span class="comment">//使能串口时钟 </span></span><br><span class="line">	GPIOA-&gt;CRH&amp;=<span class="number">0XFFFFF00F</span>;<span class="comment">//IO状态设置    10:0100--&gt;4   9:1001--&gt;9</span></span><br><span class="line">	GPIOA-&gt;CRH|=<span class="number">0X00000490</span>;<span class="comment">//IO状态设置 </span></span><br><span class="line">	RCC-&gt;APB2RSTR|=<span class="number">1</span>&lt;&lt;<span class="number">14</span>;   <span class="comment">//复位串口1</span></span><br><span class="line">	RCC-&gt;APB2RSTR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">14</span>);<span class="comment">//停止复位	   	   </span></span><br><span class="line">	<span class="comment">//波特率设置</span></span><br><span class="line"> 	USART1-&gt;BRR=mantissa; <span class="comment">// 波特率设置	 </span></span><br><span class="line">	USART1-&gt;CR1|=<span class="number">0X360C</span>;  <span class="comment">//校验位:1奇校验.数据位+1--&gt;9位  </span></span><br><span class="line">	<span class="comment">//360c--&gt;0011 0110 0000 1100</span></span><br><span class="line">	</span><br><span class="line">	USART1-&gt;CR2|=<span class="number">0X0000</span>;  <span class="comment">//1位停止  位13:12--&gt;00--&gt;1位停止</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> EN_USART1_RX  <span class="comment">//如果使能了接收</span></span></span><br><span class="line">	<span class="comment">//使能接收中断 </span></span><br><span class="line">	USART1-&gt;CR1|=<span class="number">1</span>&lt;&lt;<span class="number">5</span>; <span class="comment">//接收缓冲区非空中断使能	    	</span></span><br><span class="line">	MY_NVIC_Init(<span class="number">3</span>,<span class="number">3</span>,USART1_IRQn,<span class="number">2</span>); <span class="comment">//组2，最低优先级 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>(3). main.c：</strong>主函数，串口 1→pclk2，速度 72MHz，所以 uart_init 中修改为 72，波特率 115200</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;			</span><br><span class="line">	u8 t;</span><br><span class="line">	u8 len;	</span><br><span class="line">	u16 times=<span class="number">0</span>;  </span><br><span class="line">	Stm32_Clock_Init(<span class="number">9</span>); <span class="comment">//系统时钟设置</span></span><br><span class="line">	delay_init(<span class="number">72</span>); <span class="comment">//延时初始化 </span></span><br><span class="line">	uart_init(<span class="number">72</span>,<span class="number">115200</span>); <span class="comment">//串口初始化为115200</span></span><br><span class="line">	LED_Init(); <span class="comment">//初始化与LED连接的硬件接口    </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x8000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//得到此次接收到的数据长度  0011 1111 1111 1111  bit13~0.接收到的有效字节数目</span></span><br><span class="line">			len=USART_RX_STA&amp;<span class="number">0x3fff</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\r\n您发送的消息为:\r\n"</span>);</span><br><span class="line">			<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">			&#123;</span><br><span class="line">				USART1-&gt;DR=USART_RX_BUF[t];</span><br><span class="line">				<span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//等待发送结束</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\r\n\r\n"</span>);<span class="comment">//插入换行</span></span><br><span class="line">			USART_RX_STA=<span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			times++;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">5000</span>==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\r\nALIENTEK MiniSTM32开发板 串口实验\r\n"</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"正点原子@ALIENTEK\r\n\r\n\r\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">200</span>==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"请输入数据,以回车键结束\r\n"</span>);  </span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">30</span>==<span class="number">0</span>)LED0=!LED0;<span class="comment">//闪烁LED,提示系统正在运行.</span></span><br><span class="line">			delay_ms(<span class="number">10</span>);   </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-库函数版"><a href="#1-2-库函数版" class="headerlink" title="1.2 库函数版"></a>1.2 库函数版</h2><p><strong>(1). usart.c：</strong>配置串口 1 和 GPIOA 使能时钟，以及配置功能参数:</p>
<ul>
<li><p>初始化串口设置，设置 9 位字长数据格式（加入校验位，数据位+1）、0.5 位停止位和偶校验位(Even)；</p>
</li>
<li><p>配置串口中断优先级，抢占优先级 2 级、响应优先级 1 级；最后开启串口接受中断并使能串口 1</p>
<p><em>（仅展示修改部分代码，详细原码请下载资料包查看）</em></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串口初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(u32 bound)</span></span>&#123;</span><br><span class="line">  <span class="comment">//GPIO端口设置</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  USART_InitTypeDef USART_InitStructure;</span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	 </span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);	<span class="comment">//使能USART1，GPIOA时钟</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//USART1_TX   GPIOA.9</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; <span class="comment">//PA.9</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz; <span class="comment">//10MHz </span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class="comment">//推挽复用输出</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure); <span class="comment">//初始化GPIOA.9</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">//USART1_RX	GPIOA.10初始化</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<span class="comment">//PA10</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;<span class="comment">//下拉输入</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOA.10  </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Usart1 NVIC 配置</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span> ; <span class="comment">//抢占优先级2</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>; <span class="comment">//子优先级1 (响应)</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//IRQ通道使能</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure); <span class="comment">//根据指定的参数初始化VIC寄存器</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//USART 初始化设置</span></span><br><span class="line">  USART_InitStructure.USART_BaudRate = bound; <span class="comment">//串口波特率</span></span><br><span class="line">  USART_InitStructure.USART_WordLength = USART_WordLength_9b; <span class="comment">//字长为9位数据格式  加入1位校验位,数据位+1</span></span><br><span class="line">  USART_InitStructure.USART_StopBits = USART_StopBits_0_5; <span class="comment">//0.5个停止位</span></span><br><span class="line">  USART_InitStructure.USART_Parity = USART_Parity_Even; <span class="comment">//偶校验位</span></span><br><span class="line">  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; <span class="comment">//无硬件数据流控制</span></span><br><span class="line">  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; <span class="comment">//收发模式</span></span><br><span class="line"></span><br><span class="line">  USART_Init(USART1, &amp;USART_InitStructure); <span class="comment">//初始化串口1</span></span><br><span class="line">  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); <span class="comment">//开启串口接受中断</span></span><br><span class="line">  USART_Cmd(USART1, ENABLE); <span class="comment">//使能串口1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2). main.c：</strong>设置中断优先级分组 3，修改串口初始化波特率为 115200<em>（仅展示修改部分代码，详细原码请下载资料包查看）</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">delay_init(); <span class="comment">//延时函数初始化	</span></span><br><span class="line"><span class="comment">//设置中断优先级分组3</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);</span><br><span class="line">uart_init(<span class="number">115200</span>); <span class="comment">//串口初始化为115200</span></span><br><span class="line">LED_Init(); <span class="comment">//初始化与LED连接的硬件接口</span></span><br></pre></td></tr></table></figure>

<h1 id="2-串口5通信"><a href="#2-串口5通信" class="headerlink" title="2. 串口5通信"></a>2. 串口5通信</h1><h2 id="2-1-寄存器版"><a href="#2-1-寄存器版" class="headerlink" title="2.1 寄存器版"></a>2.1 寄存器版</h2><p><strong>(1). usart.h：</strong>头文件中自定义的函数将 USART 改为 UART，其对应的 usart.c 和 main.c 文件中对应的自定义函数名也要修改正确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_REC_LEN  			200  	<span class="comment">//定义最大接收字节数 200</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EN_UART5_RX 			1	<span class="comment">//使能（1）/禁止（0）串口1接收</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收缓冲,最大UART_REC_LEN个字节.末字节为换行符 </span></span><br><span class="line"><span class="keyword">extern</span> u8  UART_RX_BUF[UART_REC_LEN]; </span><br><span class="line"><span class="keyword">extern</span> u16 UART_RX_STA; <span class="comment">//接收状态标记	</span></span><br><span class="line"><span class="comment">//如果想串口中断接收，请不要注释以下宏定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(u32 pclk1,u32 bound)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>(2). usart.c：</strong>修改对应的自定义函数，即 USART→UART；修改 IO 口和串口 5 的使能时钟和功能参数，串口 5 对应 APB1ENR 和 APB1RSTR<em>（仅展示修改部分代码，详细原码请下载资料包查看）</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PD2-PC12  串口5</span></span><br><span class="line"><span class="comment">//初始化IO</span></span><br><span class="line"><span class="comment">//pclk1:PCLK1时钟频率(36Mhz)</span></span><br><span class="line"><span class="comment">//bound:波特率 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(u32 pclk1,u32 bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;  	 </span><br><span class="line">	<span class="keyword">float</span> temp;</span><br><span class="line">	u16 mantissa;</span><br><span class="line">	u16 fraction;	   </span><br><span class="line">	temp=(<span class="keyword">float</span>)(pclk1*<span class="number">1000000</span>)/(bound*<span class="number">16</span>); <span class="comment">//得到USARTDIV</span></span><br><span class="line">	mantissa=temp; <span class="comment">//得到整数部分</span></span><br><span class="line">	fraction=(temp-mantissa)*<span class="number">16</span>; <span class="comment">//得到小数部分	 </span></span><br><span class="line">    mantissa&lt;&lt;=<span class="number">4</span>;</span><br><span class="line">	mantissa+=fraction; </span><br><span class="line">	RCC-&gt;APB2ENR|=<span class="number">1</span>&lt;&lt;<span class="number">5</span>; <span class="comment">//使能PORTD口时钟 </span></span><br><span class="line">	RCC-&gt;APB2ENR|=<span class="number">1</span>&lt;&lt;<span class="number">4</span>; <span class="comment">//使能PORTC口时钟 </span></span><br><span class="line">	RCC-&gt;APB1ENR|=<span class="number">1</span>&lt;&lt;<span class="number">20</span>; <span class="comment">//使能串口5时钟 </span></span><br><span class="line">	</span><br><span class="line">	GPIOD-&gt;CRL&amp;=<span class="number">0XFFFFF0FF</span>; <span class="comment">//IO状态设置	PD2:0100--&gt;4,接收端浮空输入</span></span><br><span class="line">	GPIOD-&gt;CRL|=<span class="number">0X00000400</span>; <span class="comment">//IO状态设置</span></span><br><span class="line">	</span><br><span class="line">	GPIOC-&gt;CRH&amp;=<span class="number">0XFFF0FFFF</span>; <span class="comment">//IO状态设置	PC12:1001--&gt;9,发送端推挽复用，速度为10MHz</span></span><br><span class="line">	GPIOC-&gt;CRH|=<span class="number">0X00090000</span>; <span class="comment">//IO状态设置 </span></span><br><span class="line">	</span><br><span class="line">	RCC-&gt;APB1RSTR|=<span class="number">1</span>&lt;&lt;<span class="number">20</span>; <span class="comment">//复位串口5</span></span><br><span class="line">	RCC-&gt;APB1RSTR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">20</span>); <span class="comment">//停止复位	   	   </span></span><br><span class="line">	<span class="comment">//波特率设置</span></span><br><span class="line"> 	UART5-&gt;BRR=mantissa; <span class="comment">// 波特率设置	 </span></span><br><span class="line">	UART5-&gt;CR1|=<span class="number">0X360C</span>; <span class="comment">//校验位:1奇校验.数据位+1--&gt;9位  </span></span><br><span class="line">	<span class="comment">//360c--&gt;0011 0110 0000 1100</span></span><br><span class="line">	</span><br><span class="line">	UART5-&gt;CR2|=<span class="number">0X0000</span>; <span class="comment">//1位停止  位13:12--&gt;00--&gt;1位停止</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> EN_UART5_RX <span class="comment">//如果使能了接收</span></span></span><br><span class="line">	<span class="comment">//使能接收中断 </span></span><br><span class="line">	UART5-&gt;CR1|=<span class="number">1</span>&lt;&lt;<span class="number">5</span>; <span class="comment">//接收缓冲区非空中断使能	    	</span></span><br><span class="line">	MY_NVIC_Init(<span class="number">3</span>,<span class="number">3</span>,UART5_IRQn,<span class="number">2</span>); <span class="comment">//组2，最低优先级 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3). main.c：</strong>串口 5→pclk1，对应速度 36MHz，所以 uart_init 中修改为 36，波特率 115200</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;			</span><br><span class="line">	u8 t;</span><br><span class="line">	u8 len;	</span><br><span class="line">	u16 times=<span class="number">0</span>;  </span><br><span class="line">	Stm32_Clock_Init(<span class="number">9</span>); <span class="comment">//系统时钟设置</span></span><br><span class="line">	delay_init(<span class="number">36</span>);	     <span class="comment">//延时初始化 </span></span><br><span class="line">	uart_init(<span class="number">36</span>,<span class="number">115200</span>);	 <span class="comment">//串口初始化为115200</span></span><br><span class="line">	LED_Init();		  	 <span class="comment">//初始化与LED连接的硬件接口    </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(UART_RX_STA&amp;<span class="number">0x8000</span>)</span><br><span class="line">		&#123;					   </span><br><span class="line">			len=UART_RX_STA&amp;<span class="number">0x3fff</span>;<span class="comment">//得到此次接收到的数据长度</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\r\n您发送的消息为:\r\n"</span>);</span><br><span class="line">			<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">			&#123;</span><br><span class="line">				UART5-&gt;DR=UART_RX_BUF[t];</span><br><span class="line">				<span class="keyword">while</span>((UART5-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//等待发送结束</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\r\n\r\n"</span>);<span class="comment">//插入换行</span></span><br><span class="line">			UART_RX_STA=<span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			times++;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">5000</span>==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\r\nALIENTEK MiniSTM32开发板 串口实验\r\n"</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"正点原子@ALIENTEK\r\n\r\n\r\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">200</span>==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"请输入数据,以回车键结束\r\n"</span>);  </span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">30</span>==<span class="number">0</span>)LED0=!LED0;<span class="comment">//闪烁LED,提示系统正在运行.</span></span><br><span class="line">			delay_ms(<span class="number">10</span>);   </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-库函数版"><a href="#2-2-库函数版" class="headerlink" title="2.2 库函数版"></a>2.2 库函数版</h2><p><strong>(1). usart.c：</strong>配置串口 5 和 GPIOC、GPIOD 使能时钟，以及配置功能参数；初始化串口设置，设置 9 位字长数据格式（加入校验位，数据位+1）、0.5 位停止位和偶校验位 Even；配置串口中断优先级，抢占优先级 2 级、相应优先级 1 级；最后开启串口接受中断并使能串口 1。将自定义的 USART（USART1） 改为 UART（UART5）<em>（仅展示修改部分代码，详细原码请下载资料包查看）</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串口初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(u32 bound)</span></span>&#123;</span><br><span class="line">  <span class="comment">//GPIO端口设置</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  USART_InitTypeDef USART_InitStructure;</span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	 </span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE); <span class="comment">//使能UART5</span></span><br><span class="line"></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD, ENABLE); <span class="comment">//GPIOC,GPIOD时钟</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//UART5_TX	GPIOC.12</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; <span class="comment">//PC.12</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;  <span class="comment">//10MHz </span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	<span class="comment">//推挽复用输出</span></span><br><span class="line">  GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOC.12</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">//UART5_RX	GPIOD.2初始化</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; <span class="comment">//PD.2</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; <span class="comment">//下拉输入</span></span><br><span class="line">  GPIO_Init(GPIOD, &amp;GPIO_InitStructure); <span class="comment">//初始化GPIOD.2  </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//UART5 NVIC 配置</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span> ; <span class="comment">//抢占优先级2</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>; <span class="comment">//子优先级1 (响应)</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//IRQ通道使能</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure); <span class="comment">//根据指定的参数初始化VIC寄存器</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">//UART 初始化设置</span></span><br><span class="line">  USART_InitStructure.USART_BaudRate = bound;<span class="comment">//串口波特率</span></span><br><span class="line">  USART_InitStructure.USART_WordLength = USART_WordLength_9b;<span class="comment">//字长为9位数据格式  加入1位校验位,数据位+1</span></span><br><span class="line">  USART_InitStructure.USART_StopBits = USART_StopBits_0_5;<span class="comment">//0.5个停止位</span></span><br><span class="line">  USART_InitStructure.USART_Parity = USART_Parity_Even;<span class="comment">//偶校验位</span></span><br><span class="line">  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//无硬件数据流控制</span></span><br><span class="line">  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	<span class="comment">//收发模式</span></span><br><span class="line"></span><br><span class="line">  USART_Init(UART5, &amp;USART_InitStructure); <span class="comment">//初始化串口5</span></span><br><span class="line">  USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);<span class="comment">//开启串口接受中断</span></span><br><span class="line">  USART_Cmd(UART5, ENABLE);                    <span class="comment">//使能串口5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2). main.c：</strong>设置中断优先级分组 3，修改串口初始化波特率为 115200<em>（仅展示修改部分代码，详细原码请下载资料包查看）</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">delay_init(); <span class="comment">//延时函数初始化	</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3); <span class="comment">//设置中断优先级分组3</span></span><br><span class="line">uart_init(<span class="number">115200</span>); <span class="comment">//串口初始化为115200</span></span><br><span class="line">LED_Init(); <span class="comment">//初始化与LED连接的硬件接口</span></span><br></pre></td></tr></table></figure>

<h1 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3.  参考资料"></a>3.  参考资料</h1><p>串口实验原码下载：</p>
<ul>
<li>网盘下载：<a href="https://wwr.lanzoui.com/iiA5hq6h3he" target="_blank" rel="noopener">串口实验.zip</a>    密码：4mgf</li>
<li>内容包含：<ul>
<li>寄存器和库函数模板初始原码</li>
<li>按实验要求修改后的原码</li>
</ul>
</li>
</ul>
<p>嵌入式STM32学习视频：</p>
<ul>
<li>字母站传送门：<a href="https://www.bilibili.com/video/BV1kx411k7JT" target="_blank" rel="noopener">【正点原子】STM32开发板实验教程</a></li>
</ul>
<div class="note info">
            <p>所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途<br>想看更多有关【嵌入式STM32】的文章可以前往：<strong><a href="/undefined/64afecd0.html" title="【嵌入式STM32】文章汇总">【嵌入式STM32】文章汇总</a></strong> </p>
          </div>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>将网站迁移到Vercel托管</title>
    <url>/undefined/86d73a10.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="关于Vercel"><a href="#关于Vercel" class="headerlink" title="关于Vercel"></a>关于Vercel</h2><p>首先，Vercel是免费的网站托管商，其中有许多大官网如<code>Next.js</code>,<code>create-react-app</code>,<code>Nuxt.js</code>等就是部署在部署托管在<code>vercel</code>的。同时Vercel操作简单友好，支持从github、gitlab的代码库中一键导入，支持自定义域名和SSL证书配置。访问速度也很可观，简直就是<del>白嫖党</del>的福音。</p>
<a id="more"></a>

<h2 id="为什么取消了在coding上的托管"><a href="#为什么取消了在coding上的托管" class="headerlink" title="为什么取消了在coding上的托管"></a>为什么取消了在coding上的托管</h2><p>原来本站是部署到coding上来托管的，但由于现在coding网站托管和腾讯云打通并且开始主推新版，旧版迟早是要被淘汰的（现在我在旧版coding托管的网站IP已经ping不到了），不得不迁移到腾讯云上。</p>
<blockquote>
<p>CODING Pages 依托腾讯云资源提供相关静态托管能力，CODING 平台本身不收取任何费用。该产品使用了腾讯云对象存储 COS、内容分发网络 CDN、SSL 证书产品，其中 COS 和 CDN 采用用量计费模式，SSL 证书免费，所使用到的其他相关腾讯云产品本身亦会有一定的免费额度。</p>
</blockquote>
<p>也就是迁移新版是需要收费的，个人网站费用不高，域名不是已经备案的网站的话，可以选择香港的服务器节点，但其实这新版很鸡肋。</p>
<h3 id="迁移新版后国内访问速度再起不能？"><a href="#迁移新版后国内访问速度再起不能？" class="headerlink" title="迁移新版后国内访问速度再起不能？"></a>迁移新版后国内访问速度再起不能？</h3><p>在设置好自定义域名后，网站在部署时会申请SSL证书，同时检验是否部署好COS实例，即使后面关闭了也会自动打开（尝试白嫖失败T^T），部署好后试着用域名去访问发现速度大大下跌，像校园网这种比较差的网络环境有时候根本打不开，查阅文章得知这是绕了地球一圈？好家伙，说好的香港节点呢(???￢_￢)</p>
<ul>
<li>关于迁移新版速度可以参考这篇文章：<a href="https://blog.csdn.net/nanshanvc/article/details/110454607" target="_blank" rel="noopener">CODING Pages 静态网站升级腾讯云新版踩坑小记</a> </li>
</ul>
<h1 id="如何在Vercel上部署"><a href="#如何在Vercel上部署" class="headerlink" title="如何在Vercel上部署"></a>如何在Vercel上部署</h1><h2 id="导入及部署"><a href="#导入及部署" class="headerlink" title="导入及部署"></a>导入及部署</h2><ol>
<li><p>先成功部署Github Pages</p>
</li>
<li><p><a href="https://vercel.com/" target="_blank" rel="noopener">Vercel官网</a>，登录/注册账号，关联Github账号，一键导入（这里以新用户注册讲解）</p>
</li>
<li><p>跟随向导，关联好Github帐号后可以寻找库中的代码，选择<strong>Only select repositories</strong> 指定库中项目（也可以选择ALL，建议选择需要的就可以了）</p>
<img src="https://pic.imgdb.cn/item/6098aff2d1a9ae528f35bc6a.png" style="zoom: 50%;">
</li>
<li><p>Import一键导入，导入后即可自动部署成功</p>
<img src="https://pic.imgdb.cn/item/6098b085d1a9ae528f399093.png" style="zoom:50%">



</li>
</ol>
<h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>部署成功后，进入项目，找到 <strong>Settings —&gt; Domains</strong> 。</p>
<img src="https://pic.imgdb.cn/item/6098bca5d1a9ae528f99455b.png" style="zoom:50%">

<p>添加后会提示重定向到哪个域名，也就是当输入 <code>baidu.com</code> 时会重定向到 <code>www.baidu.com</code> 的意思，当然反过来也可以，然后按要求配置好DNS的解析即可</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>Vercel的配置还是比较简单的，就是我的域名是在DNSPOD上解析的，所以没有配置vercel的NS会一直报配置不正确，但可以正常访问就可以了。</p>
<p>除了Vercel，还有一个免费的托管商 <strong><a href="https://www.netlify.com/" target="_blank" rel="noopener">Netlify</a></strong> ，时间有限就不多折腾了，有兴趣的同学可以自行去查看。</p>
<h4 id="补充（2021年5月31日更新）"><a href="#补充（2021年5月31日更新）" class="headerlink" title="补充（2021年5月31日更新）"></a>补充（2021年5月31日更新）</h4><p>1、前期在vercel使用自定义域名部署的网站在国内已经无法访问了（亲测翻墙可以访问，不翻墙无法访问），经过辛苦查找各大网站，终于在知乎一篇文章的评论下发现了有用的信息：</p>
<div class="note warning">
            <p>官方已经对此问题响应，把A记录改成<code>76.223.126.88</code>，或把CNAME改成<code>cname-china.vercel-dns.com</code> （至于响应在哪个位置待我有时间去找找，知道的同学可以通过Email提示一下）<br>注意：这两项修改均是在vercel的DNS解析中修改，且默认记录是无法修改的，直接Add就行。</p>
          </div>

<p>2、使用vercel出现的DNS解析的问题，建议暂停在DNSPOD解析，直接在域名商解析，这样就不会出现配置报错问题了，同时也是为了避免服务器找不到的问题。</p>
<div class="note info">
            <p>本文参考：<a href="https://zhuanlan.zhihu.com/p/338057700" target="_blank" rel="noopener">如何将 github pages 迁移到 vercel 上托管</a><br>有关 <strong>Netlify</strong> 的部署可参考：<a href="https://zhuanlan.zhihu.com/p/338058109" target="_blank" rel="noopener">如何将网站代码部署到 netlify 上免费托管</a></p>
          </div>]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【嵌入式STM32】（三）按键亮灯实验</title>
    <url>/undefined/44c24675.html</url>
    <content><![CDATA[<h1 id="0-实验要求"><a href="#0-实验要求" class="headerlink" title="0. 实验要求"></a>0. 实验要求</h1><p>掌握寄存器和库函数两个版本的<strong>按键亮灯</strong>实验</p>
<p><u>LED灯</u>接端口 <strong>PC8—PC11</strong>，<u>按键</u>接端口 <strong>PC0—PC3</strong>，全部设置成<strong>上拉模式</strong>，实现：</p>
<ul>
<li>一个按键控制一个灯</li>
<li>一个按键控制两个灯</li>
</ul>
<a id="more"></a>

<h1 id="1-一个按键控制一个灯"><a href="#1-一个按键控制一个灯" class="headerlink" title="1. 一个按键控制一个灯"></a>1. 一个按键控制一个灯</h1><h2 id="1-1-寄存器版"><a href="#1-1-寄存器版" class="headerlink" title="1.1 寄存器版"></a>1.1 寄存器版</h2><p><strong>(1). key.h：</strong>配置 4 个按键状态，初始化 IO</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0_PRES	1	<span class="comment">//KEY0按下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY1_PRES	2	<span class="comment">//KEY1按下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY2_PRES	3	<span class="comment">//KEY2按下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY3_PRES	4	<span class="comment">//KEY3按下</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0  PCin(0)   <span class="comment">//PC0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY1  PCin(1)	<span class="comment">//PC1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY2  PCin(2)	<span class="comment">//PC2 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY3  PCin(3)	<span class="comment">//PC3 </span></span></span><br><span class="line">	 </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//IO初始化</span></span><br><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span>;	<span class="comment">//按键扫描函数</span></span><br></pre></td></tr></table></figure>

<p><strong>(2). key.c：</strong></p>
<ul>
<li>使能 PORTC 时钟，设置按键 PC0—PC3 的 CNF 为上拉模式，MODE 为输入模式。根据参考手册可知，CNF:上/下拉模式 –&gt; 10，MODE:输入模式 –&gt; 00，所以1000 –&gt; 8</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按键初始化函数 </span></span><br><span class="line"><span class="comment">//PC0和PC3 设置成输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC-&gt;APB2ENR|=<span class="number">1</span>&lt;&lt;<span class="number">4</span>;     <span class="comment">//使能PORTC时钟</span></span><br><span class="line">	JTAG_Set(SWD_ENABLE);	<span class="comment">//关闭JTAG,开启SWD</span></span><br><span class="line">	</span><br><span class="line">	GPIOC-&gt;CRL&amp;=<span class="number">0XFFFFFFF0</span>;	<span class="comment">//PC0设置成输入</span></span><br><span class="line">    <span class="comment">// 1000 -&gt; 8  CNF:上/下拉模式 -&gt; 10;MODE:输入模式 -&gt; 00</span></span><br><span class="line">	GPIOC-&gt;CRL|=<span class="number">0X00000008</span>;</span><br><span class="line">	GPIOC-&gt;ODR|=<span class="number">1</span>&lt;&lt;<span class="number">0</span>;	<span class="comment">//PC0上拉	</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//PC1设置成输入。ODR寄存器默认为0即下拉，不用设置PA0下拉</span></span><br><span class="line">	GPIOC-&gt;CRL&amp;=<span class="number">0XFFFFFF0F</span>;</span><br><span class="line">	GPIOC-&gt;CRL|=<span class="number">0X00000080</span>; 			 </span><br><span class="line">	GPIOC-&gt;ODR|=<span class="number">1</span>&lt;&lt;<span class="number">1</span>; <span class="comment">//PC1上拉</span></span><br><span class="line">	</span><br><span class="line">	GPIOC-&gt;CRL&amp;=<span class="number">0XFFFFF0FF</span>;	<span class="comment">//PC2设置成输入	  </span></span><br><span class="line">	GPIOC-&gt;CRL|=<span class="number">0X00000800</span>;   </span><br><span class="line">	GPIOC-&gt;ODR|=<span class="number">1</span>&lt;&lt;<span class="number">2</span>;	<span class="comment">//PC2上拉 </span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	GPIOC-&gt;CRL&amp;=<span class="number">0XFFFF0FFF</span>;	<span class="comment">//PC3设置成输入	  </span></span><br><span class="line">	GPIOC-&gt;CRL|=<span class="number">0X00008000</span>;   </span><br><span class="line">	GPIOC-&gt;ODR|=<span class="number">1</span>&lt;&lt;<span class="number">3</span>;	<span class="comment">//PC3上拉 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>按键处理函数 u8 KEY_Scan(u8 mode)，mode:0,不支持连续按;1, 支持连续按; 返回值：0，表示没有任何按键按下，KEY0_PRES，KEY0 按下， 其余按键也是如此</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按键处理(扫描)函数</span></span><br><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;	 </span><br><span class="line">	<span class="keyword">static</span> u8 key_up=<span class="number">1</span>;<span class="comment">//按键按松开标志</span></span><br><span class="line">	<span class="keyword">if</span>(mode)key_up=<span class="number">1</span>;  <span class="comment">//支持连按		  </span></span><br><span class="line">	<span class="keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="number">0</span>||KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		delay_ms(<span class="number">10</span>);<span class="comment">//去抖动 </span></span><br><span class="line">		key_up=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(KEY0==<span class="number">0</span>)<span class="keyword">return</span> KEY0_PRES;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">0</span>)<span class="keyword">return</span> KEY1_PRES;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)<span class="keyword">return</span> KEY2_PRES;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)<span class="keyword">return</span> KEY3_PRES; </span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY0==<span class="number">1</span>&amp;&amp;KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>)key_up=<span class="number">1</span>; 	     </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 无按键按下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3). led.h：</strong>LED 端口定义及初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LED端口定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0 PCout(8)	<span class="comment">// PC8</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 PCout(9)	<span class="comment">// PC9	</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2 PCout(10)	<span class="comment">// PC10</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3 PCout(11)	<span class="comment">// PC11</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>

<p><strong>(4). led.c：</strong>LED IO初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化PC8-PC11为输出口.并使能时钟		    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC-&gt;APB2ENR|=<span class="number">1</span>&lt;&lt;<span class="number">4</span>;    <span class="comment">//使能PORTC时钟   	 </span></span><br><span class="line">	GPIOC-&gt;CRH&amp;=<span class="number">0XFFFF0000</span>; </span><br><span class="line">	GPIOC-&gt;CRH|=<span class="number">0X00003333</span>;<span class="comment">//PC8-PC11 推挽输出 </span></span><br><span class="line">    </span><br><span class="line">	GPIOC-&gt;ODR|=<span class="number">1</span>&lt;&lt;<span class="number">8</span>;      <span class="comment">//PC8 输出高</span></span><br><span class="line">	GPIOC-&gt;ODR|=<span class="number">1</span>&lt;&lt;<span class="number">9</span>;      <span class="comment">//PC9输出高 </span></span><br><span class="line">	GPIOC-&gt;ODR|=<span class="number">1</span>&lt;&lt;<span class="number">10</span>;     <span class="comment">//PC10输出高 </span></span><br><span class="line">	GPIOC-&gt;ODR|=<span class="number">1</span>&lt;&lt;<span class="number">11</span>;     <span class="comment">//PC11输出高 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(5). main.c：</strong>主函数。设置循环判断按键状态的返回值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;		 </span><br><span class="line">	vu8 t;	  </span><br><span class="line">	Stm32_Clock_Init(<span class="number">9</span>); 	<span class="comment">//系统时钟设置</span></span><br><span class="line">	delay_init(<span class="number">72</span>);	     	<span class="comment">//延时初始化 </span></span><br><span class="line">	LED_Init();		  	 	<span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">	KEY_Init();          	<span class="comment">//初始化与按键连接的硬件接口</span></span><br><span class="line">	LED0=<span class="number">1</span>;					<span class="comment">//LED初始状态</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		t=KEY_Scan(<span class="number">0</span>);		<span class="comment">//得到键值</span></span><br><span class="line">		<span class="keyword">switch</span>(t)</span><br><span class="line">		&#123;				 </span><br><span class="line">			<span class="keyword">case</span> KEY0_PRES:</span><br><span class="line">				LED0=!LED0;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY1_PRES:</span><br><span class="line">				LED1=!LED1;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY2_PRES:</span><br><span class="line">				LED2=!LED2;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY3_PRES:</span><br><span class="line">				LED3=!LED3;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				delay_ms(<span class="number">10</span>);	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;		 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-库函数版"><a href="#1-2-库函数版" class="headerlink" title="1.2 库函数版"></a>1.2 库函数版</h2><p><strong>(1). key.h：</strong>配置 4 个按键状态，初始化 IO</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0  GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_0)<span class="comment">//读取按键0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY1  GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_1)<span class="comment">//读取按键1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY2  GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_2)<span class="comment">//读取按键2 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY3  GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_3)<span class="comment">//读取按键3</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0_PRES	1	<span class="comment">//KEY0  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY1_PRES	2	<span class="comment">//KEY1 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY2_PRES	3	<span class="comment">//KEY2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY3_PRES	4	<span class="comment">//KEY3</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//IO初始化</span></span><br><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span>;  	<span class="comment">//按键扫描函数</span></span><br></pre></td></tr></table></figure>

<p><strong>(2). key.c：</strong></p>
<ul>
<li>使能 PORTC 时钟，设置按键 PC0—PC3 为上拉模式，初始化 GPIOC</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按键初始化函数 </span></span><br><span class="line"><span class="comment">//PC0-PC3 设置成输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使能PORTC时钟</span></span><br><span class="line"> 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭JTAG，使能SWD，可以用SWD模式调试</span></span><br><span class="line">	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;<span class="comment">//PC0</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<span class="comment">//设置成上拉输入</span></span><br><span class="line"> 	GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOC0</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_1;<span class="comment">//PC1</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<span class="comment">//设置成上拉输入</span></span><br><span class="line"> 	GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOC1</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_2;<span class="comment">//PC2</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">//设置成上拉输入</span></span><br><span class="line"> 	GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOC2</span></span><br><span class="line"> </span><br><span class="line">	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_3;<span class="comment">//PC3</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<span class="comment">//设置成上拉输入 </span></span><br><span class="line">	GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOC3</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>按键处理函数 u8 KEY_Scan(u8 mode)，mode:0, 不支持连续按;1,支持连续按; 返回值：0，表示没有任何按键按下， KEY0_PRES，KEY0 按下，其余按键也是如此</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;	 </span><br><span class="line">	<span class="keyword">static</span> u8 key_up=<span class="number">1</span>;<span class="comment">//按键按松开标志</span></span><br><span class="line">	<span class="keyword">if</span>(mode)key_up=<span class="number">1</span>;  <span class="comment">//支持连按		  </span></span><br><span class="line">	<span class="keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="number">0</span>||KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		delay_ms(<span class="number">10</span>);<span class="comment">//去抖动 </span></span><br><span class="line">		key_up=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(KEY0==<span class="number">0</span>)<span class="keyword">return</span> KEY0_PRES;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">0</span>)<span class="keyword">return</span> KEY1_PRES;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)<span class="keyword">return</span> KEY2_PRES;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)<span class="keyword">return</span> KEY3_PRES;		</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY0==<span class="number">1</span>&amp;&amp;KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>)key_up=<span class="number">1</span>; 	     </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 无按键按下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3). led.h：</strong>LED 端口定义及初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0 PCout(8)	<span class="comment">// PC8</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 PCout(9)	<span class="comment">// PC9</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2 PCout(10)	<span class="comment">// PC10</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3 PCout(11)	<span class="comment">// PC11</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>

<p><strong>(4). led.c：</strong>初始化 PC8—PC11 为输出口.并使能 PORTC 时钟，初始化 LED IO</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化PC8-PC11为输出口.并使能时钟		    </span></span><br><span class="line"><span class="comment">//LED IO初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"> 	</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);<span class="comment">//使能PC端口时钟</span></span><br><span class="line"></span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;<span class="comment">//LED0--&gt;PC8 端口配置</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//推挽输出</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//IO口速度为50MHz</span></span><br><span class="line"> GPIO_Init(GPIOC, &amp;GPIO_InitStructure);	<span class="comment">//根据设定参数初始化GPIOC.8</span></span><br><span class="line"> GPIO_SetBits(GPIOC,GPIO_Pin_8);<span class="comment">//PC8 输出高</span></span><br><span class="line"></span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<span class="comment">//LED1--&gt;PC9 端口配置</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//推挽输出</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//IO口速度为50MHz</span></span><br><span class="line"> GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<span class="comment">//根据设定参数初始化GPIOC.9</span></span><br><span class="line"> GPIO_SetBits(GPIOC,GPIO_Pin_9);<span class="comment">//PC9 输出高</span></span><br><span class="line">	</span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<span class="comment">//LED2--&gt;PC10 端口配置</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//推挽输出</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//IO口速度为50MHz</span></span><br><span class="line"> GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<span class="comment">//根据设定参数初始化GPIOC.10</span></span><br><span class="line"> GPIO_SetBits(GPIOC,GPIO_Pin_10);<span class="comment">//PC10 输出高</span></span><br><span class="line"> </span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;<span class="comment">//LED3--&gt;PC11 端口配置</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//推挽输出</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//IO口速度为50MHz</span></span><br><span class="line"> GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<span class="comment">//根据设定参数初始化GPIOC.11</span></span><br><span class="line"> GPIO_SetBits(GPIOC,GPIO_Pin_11);<span class="comment">//PC11 输出高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(5). main.c：</strong>主函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;	</span><br><span class="line">	u8 t=<span class="number">0</span>;	  </span><br><span class="line">	delay_init(); <span class="comment">//延时函数初始化	  </span></span><br><span class="line">	LED_Init(); <span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">	KEY_Init(); <span class="comment">//初始化与按键连接的硬件接口</span></span><br><span class="line">	LED0=<span class="number">0</span>;	 <span class="comment">//初始化LED</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		t=KEY_Scan(<span class="number">0</span>);	<span class="comment">//得到键值</span></span><br><span class="line">		<span class="keyword">switch</span>(t)</span><br><span class="line">		&#123;				 </span><br><span class="line">			<span class="keyword">case</span> KEY0_PRES:</span><br><span class="line">				LED0=!LED0;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY1_PRES:</span><br><span class="line">				LED1=!LED1;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY2_PRES:				</span><br><span class="line">				LED2=!LED2;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY3_PRES:				</span><br><span class="line">				LED3=!LED3;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				delay_ms(<span class="number">10</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-一个按键控制两个灯"><a href="#2-一个按键控制两个灯" class="headerlink" title="2. 一个按键控制两个灯"></a>2. 一个按键控制两个灯</h1><p>例如按下按键1:LED 1、3亮；按键2:LED 2、4亮；按键3:LED 1、2亮；按键4:LED 3、4亮</p>
<p>对于这个实验，只需要修改 <strong>一个按键控制一个灯</strong> 的主函数就可以实现，所以按键实验主要以学好上面的实验为主</p>
<h2 id="2-1-寄存器和库函数的主函数相同"><a href="#2-1-寄存器和库函数的主函数相同" class="headerlink" title="2.1 寄存器和库函数的主函数相同"></a>2.1 寄存器和库函数的主函数相同</h2><p><strong>main.c：</strong>主函数。为避免控制两个灯时出现问题，需要给所有的LED灯设置一下初值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;		 </span><br><span class="line">	vu8 t;	  </span><br><span class="line">	Stm32_Clock_Init(<span class="number">9</span>); 	<span class="comment">//系统时钟设置</span></span><br><span class="line">	delay_init(<span class="number">72</span>);	     	<span class="comment">//延时初始化 </span></span><br><span class="line">	LED_Init();		  	 	<span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">	KEY_Init();          	<span class="comment">//初始化与按键连接的硬件接口</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给4个LED灯设置初值</span></span><br><span class="line">	LED0=<span class="number">1</span>;</span><br><span class="line">	LED1=<span class="number">1</span>;</span><br><span class="line">	LED2=<span class="number">1</span>;</span><br><span class="line">	LED3=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		t=KEY_Scan(<span class="number">0</span>);	<span class="comment">//得到键值</span></span><br><span class="line">		<span class="keyword">switch</span>(t)</span><br><span class="line">		&#123;				 </span><br><span class="line">			<span class="keyword">case</span> KEY0_PRES:</span><br><span class="line">				LED0=!LED0;</span><br><span class="line">				LED2=!LED2;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY1_PRES:</span><br><span class="line">				LED1=!LED1;</span><br><span class="line">				LED3=!LED3;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY2_PRES:</span><br><span class="line">				LED0=!LED0;</span><br><span class="line">				LED1=!LED1;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY3_PRES:</span><br><span class="line">				LED3=!LED3;</span><br><span class="line">				LED2=!LED2;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				delay_ms(<span class="number">10</span>);	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;		 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3.  参考资料"></a>3.  参考资料</h1><p>按键实验源码下载：</p>
<ul>
<li>网盘下载：<a href="https://wwr.lanzoui.com/iRFbAq6guoh" target="_blank" rel="noopener">按键亮灯实验.zip</a>    密码：edu5</li>
<li>内容包含：<ul>
<li>寄存器和库函数模板初始原码</li>
<li>按实验要求修改后的原码</li>
</ul>
</li>
</ul>
<p>嵌入式STM32学习视频：</p>
<ul>
<li>字母站传送门：<a href="https://www.bilibili.com/video/BV1kx411k7JT" target="_blank" rel="noopener">【正点原子】STM32开发板实验教程</a></li>
</ul>
<div class="note info">
            <p>所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途<br>想看更多有关【嵌入式STM32】的文章可以前往：<strong><a href="/undefined/64afecd0.html" title="【嵌入式STM32】文章汇总">【嵌入式STM32】文章汇总</a></strong> </p>
          </div>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>【嵌入式STM32】（二）跑马灯实验</title>
    <url>/undefined/35ffacf0.html</url>
    <content><![CDATA[<h1 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h1><p>使用PA8和PD2端口，用寄存器和库函数两个模板实现</p>
<a id="more"></a>

<h2 id="寄存器版"><a href="#寄存器版" class="headerlink" title="寄存器版"></a>寄存器版</h2><p><strong>led.h：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LED端口定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0 PAout(8)	<span class="comment">// PA8</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 PDout(2)	<span class="comment">// PD2	</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>

<p><strong>led.c：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化PA8和PD2为输出口.并使能这两个口的时钟</span></span><br><span class="line"><span class="comment">//LED IO初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC-&gt;APB2ENR|=<span class="number">1</span>&lt;&lt;<span class="number">2</span>;    <span class="comment">//使能PORTA时钟</span></span><br><span class="line">	RCC-&gt;APB2ENR|=<span class="number">1</span>&lt;&lt;<span class="number">5</span>;    <span class="comment">//使能PORTD时钟</span></span><br><span class="line">	GPIOA-&gt;CRH&amp;=<span class="number">0XFFFFFFF0</span>; </span><br><span class="line">	GPIOA-&gt;CRH|=<span class="number">0X00000003</span>;		<span class="comment">//PA8 推挽输出</span></span><br><span class="line">	GPIOA-&gt;ODR|=<span class="number">1</span>&lt;&lt;<span class="number">8</span>;     		<span class="comment">//PA8 输出高</span></span><br><span class="line">    </span><br><span class="line">	GPIOD-&gt;CRL&amp;=<span class="number">0XFFFFF0FF</span>;</span><br><span class="line">	GPIOD-&gt;CRL|=<span class="number">0X00000300</span>;<span class="comment">//PD.2推挽输出</span></span><br><span class="line">	GPIOD-&gt;ODR|=<span class="number">1</span>&lt;&lt;<span class="number">2</span>;      <span class="comment">//PD.2输出高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>main.c：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;		 </span><br><span class="line">	Stm32_Clock_Init(<span class="number">9</span>); 	<span class="comment">//系统时钟设置</span></span><br><span class="line">	delay_init(<span class="number">72</span>);	     	<span class="comment">//延时初始化</span></span><br><span class="line">	LED_Init();		<span class="comment">//初始化与LED连接的硬件接口    </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED0=<span class="number">0</span>;</span><br><span class="line">		LED1=<span class="number">1</span>;</span><br><span class="line">		delay_ms(<span class="number">300</span>);</span><br><span class="line">		LED0=<span class="number">1</span>;</span><br><span class="line">		LED1=<span class="number">0</span>;</span><br><span class="line">		delay_ms(<span class="number">300</span>);</span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="库函数版"><a href="#库函数版" class="headerlink" title="库函数版"></a>库函数版</h2><p><strong>led.h：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0 PAout(8)	<span class="comment">// PA8</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 PDout(2)	<span class="comment">// PD2	</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>

<p><strong>led.c：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化PA8和PD2为输出口.并使能这两个口的时钟		    </span></span><br><span class="line"><span class="comment">//LED IO初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//使能PA,PD端口时钟</span></span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOD, ENABLE);	</span><br><span class="line">	</span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;	<span class="comment">//LED0--&gt;PA.8 端口配置</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//推挽输出</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//IO口速度为50MHz</span></span><br><span class="line"> GPIO_Init(GPIOA, &amp;GPIO_InitStructure);	<span class="comment">//根据设定参数初始化GPIOA.8</span></span><br><span class="line"> GPIO_SetBits(GPIOA,GPIO_Pin_8); <span class="comment">//PA.8 输出高</span></span><br><span class="line"></span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;<span class="comment">//LED1--&gt;PD.2 端口配置, 推挽输出</span></span><br><span class="line"> GPIO_Init(GPIOD, &amp;GPIO_InitStructure);<span class="comment">//推挽输出 ，IO口速度为50MHz</span></span><br><span class="line"> GPIO_SetBits(GPIOD,GPIO_Pin_2);  <span class="comment">//PD.2 输出高 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>main.c：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;	</span><br><span class="line">	delay_init(); <span class="comment">//延时函数初始化	  </span></span><br><span class="line">	LED_Init();	<span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED0=<span class="number">0</span>;</span><br><span class="line">		LED1=<span class="number">1</span>;</span><br><span class="line">		delay_ms(<span class="number">300</span>);	 <span class="comment">//延时300ms</span></span><br><span class="line">		LED0=<span class="number">1</span>;</span><br><span class="line">		LED1=<span class="number">0</span>;</span><br><span class="line">		delay_ms(<span class="number">300</span>);	<span class="comment">//延时300ms</span></span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>修改代码，用库函数模板实现战舰版跑马灯</p>
<p>其中 <strong>PA8 和 PD2 改为 PE5 和 PB5、开漏输出、10MHz</strong></p>
<p>代码敬请期待~ ~ ~</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>跑马灯实验源码下载：</p>
<ul>
<li>网盘下载：<a href="https://wwr.lanzoui.com/iFnm2q4wble" target="_blank" rel="noopener">跑马灯实验（含寄存器和库函数）.zip</a>    密码：8k6g</li>
</ul>
<p>嵌入式STM32学习视频：</p>
<ul>
<li>字母站传送门：<a href="https://www.bilibili.com/video/BV1kx411k7JT" target="_blank" rel="noopener">【正点原子】STM32开发板实验教程</a></li>
</ul>
<div class="note info">
            <p>所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途<br>想看更多有关【嵌入式STM32】的文章可以前往：<strong><a href="/undefined/64afecd0.html" title="【嵌入式STM32】文章汇总">【嵌入式STM32】文章汇总</a></strong> </p>
          </div>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>【嵌入式STM32】（一）新建库函数版和寄存器版工程模板</title>
    <url>/undefined/fc8a844.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开个新坑，STM32的相关文章是作者大三第二学期学习嵌入式这门课程的相关记录和总结。理论部分我们主要学习 STM32F103ZET6 和 STM32F103RCT6；而实验部分使用的是 STM32F103VCT6。不用担心，它们在学习上差别不是很大。</p>
<h1 id="新建库函数版和寄存器版工程模板"><a href="#新建库函数版和寄存器版工程模板" class="headerlink" title="新建库函数版和寄存器版工程模板"></a>新建库函数版和寄存器版工程模板</h1><p>在做实验前，当然是要先建好工程模板才能进行下一项操作啦，STM32的开篇文章就以新建工程模板开始。</p>
<a id="more"></a>

<p>首先STM32的代码分为寄存器版本和库函数版本，实验环境是 Keil 5 和 MDK5。这次笔记记录在幕布中，分享链接如下：</p>
<div class="note success">
            <p>STM32新建工程模板笔记：</p><ul><li>幕布传送门：文档链接:  <a href="https://share.mubu.com/doc/3_-lVqCPlu3" target="_blank" rel="noopener">https://share.mubu.com/doc/3_-lVqCPlu3</a>  密码: lzh9</li></ul><p>相关文件：</p><ul><li>包含寄存器和库函数的模板</li><li>STM32F10x_StdPeriph_Lib_V3.5.0 文件</li><li>分享链接：<ul><li>网盘下载: <a href="https://wwr.lanzoui.com/itX1Spyuqvg" target="_blank" rel="noopener">新建工程模板.zip</a>   密码:3fg5</li></ul></li></ul><p>嵌入式STM32学习视频：</p><ul><li>字母站传送门：<a href="https://www.bilibili.com/video/BV1kx411k7JT" target="_blank" rel="noopener">【正点原子】STM32开发板实验教程</a></li></ul>
          </div>



<h1 id="关于笔记的说明"><a href="#关于笔记的说明" class="headerlink" title="关于笔记的说明"></a>关于笔记的说明</h1><p>其实博客的文章更多是总结出笔记的终稿，然后再将它们上传，需要一定的时间去撰写。而在日常中，除了手写做笔记，我还使用<strong>幕布</strong>，幕布是一款思维导图软件，风格简约。在记录笔记时使用的是大纲模式，分层要更加明显，可以从大纲模式转为思维导图模式，同时还可以生成链接分享自己的笔记，是一款不错的笔记软件。所以我在幕布上有相关文章的笔记的话会附上分享链接，通过看大纲或思维导图更直观地进行学习。</p>
<div class="note info">
            <p>所有提供的资料和笔记仅供学习使用，未经许可请勿用于其他用途<br>想看更多有关【嵌入式STM32】的文章可以前往：<strong><a href="/undefined/64afecd0.html" title="【嵌入式STM32】文章汇总">【嵌入式STM32】文章汇总</a></strong> </p>
          </div>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>【C51单片机】（五）数码管动态显示 00—20</title>
    <url>/undefined/fc63a592.html</url>
    <content><![CDATA[<h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><p>使用共阴极数码管动态显示 00—20，要求 P1.0—P1.7 接 a—dp，P2.0 接1，P2.1 接2。</p>
<h2 id="动态显示和静态显示"><a href="#动态显示和静态显示" class="headerlink" title="动态显示和静态显示"></a>动态显示和静态显示</h2><h3 id="静态显示"><a href="#静态显示" class="headerlink" title="静态显示"></a>静态显示</h3><p>就是每一个数码管的段码都要独占具有锁存功能的输出口, CPU把要显示的字码送到输出口上,就可以使数码管显示对应的字符, 直到下一次送出另外一个字码之前, 显示的内容一直不会消失</p>
<a id="more"></a>

<h3 id="动态显示"><a href="#动态显示" class="headerlink" title="动态显示"></a>动态显示</h3><p>就是把所有显示器的8个段码中的A-dp的各个相同段连接在一起, 接到一个公共的输出口上,而数码管的位端分别接在另外的输出口上,通过这两个输出口的两组信号相互作用来产生显示效果。即让各位数码管按照一定顺序轮流显示, 只要扫描频率足够高, 由于人眼的“ 视觉暂留”现象,就能连续稳定的显示</p>
<div class="note success">
            <p>静态显示优点：显示稳定、亮度大, 节约CPU时间, 但占有I/O口线较多, 硬件成本高。<br>动态显示优点：其特点在于能显著降低显示部分成本,大大减少显示接口的连线结构。<br>举例, 静态驱动4位数码管, 需要4×8=32个I/O口, 而动态的驱动位数码管只需要4+8=12个I/O口。</p>
          </div>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> code table[<span class="number">10</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;time;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">			;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">21</span>;n++)</span><br><span class="line">		&#123;</span><br><span class="line">			P1=table[n/<span class="number">10</span>];</span><br><span class="line">			P2=<span class="number">0xfe</span>;</span><br><span class="line">			<span class="built_in">delay</span>(<span class="number">300</span>);</span><br><span class="line">			P2=<span class="number">0xff</span>;</span><br><span class="line">			P1=table[n%<span class="number">10</span>];</span><br><span class="line">			P2=<span class="number">0xfd</span>;</span><br><span class="line">			<span class="built_in">delay</span>(<span class="number">300</span>);</span><br><span class="line">			P2=<span class="number">0xff</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		P1=<span class="number">0x00</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调整延时函数 delay() 可以控制显示速度的快慢</p>
</blockquote>
<h2 id="仿真演示"><a href="#仿真演示" class="headerlink" title="仿真演示"></a>仿真演示</h2><img src="https://img.imgdb.cn/item/60759bf58322e6675c7c336a.gif" style="zoom:60%">]]></content>
      <categories>
        <category>嵌入式</category>
        <category>C51单片机</category>
      </categories>
      <tags>
        <tag>C51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>【C51单片机】（四）按钮控制数码管显示00&lt;==&gt;20体验</title>
    <url>/undefined/82b44f.html</url>
    <content><![CDATA[<h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><p>P1和P1接两个<strong>共阴极</strong>的数码管，P3.2接一个按钮，P3.3接一个按钮。</p>
<p>按下3.3，2个数码管从00显示到20；按下3.3，2个数码管从20减到00</p>
<p>3.2闭合，3.3断开，00-20；3.3断开，3.2闭合，20-00</p>
<a id="more"></a>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义共阴极数值表</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> code dofly_table[<span class="number">10</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;time;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">		;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//开启时，数码管显示00</span></span><br><span class="line">	P1=<span class="number">0x3f</span>;</span><br><span class="line">	P2=<span class="number">0x3f</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(P3==<span class="number">0xfb</span>)  <span class="comment">//按下P3.2</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(c=<span class="number">0</span>;c&lt;<span class="number">20</span>;c++)</span><br><span class="line">			&#123;</span><br><span class="line">				P1=dofly_table[c/<span class="number">10</span>];</span><br><span class="line">				P2=dofly_table[c%<span class="number">10</span>];</span><br><span class="line">				<span class="built_in">delay</span>(<span class="number">30</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(P3==<span class="number">0xf7</span>)  <span class="comment">//按下P3.3</span></span><br><span class="line">		&#123;	</span><br><span class="line">				<span class="keyword">for</span>(c=<span class="number">20</span>;c&gt;<span class="number">0</span>;c--)</span><br><span class="line">				&#123;</span><br><span class="line">					P1=dofly_table[c/<span class="number">10</span>];</span><br><span class="line">					P2=dofly_table[c%<span class="number">10</span>];</span><br><span class="line">					<span class="built_in">delay</span>(<span class="number">30</span>);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		P1=dofly_table[c/<span class="number">10</span>];</span><br><span class="line">		P2=dofly_table[c%<span class="number">10</span>];</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="仿真演示"><a href="#仿真演示" class="headerlink" title="仿真演示"></a>仿真演示</h2><img src="https://img.imgdb.cn/item/60759a3a8322e6675c782b3c.gif" style="zoom:50%">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本次实验需要熟悉共阴极数码管的数值表，以及P3.2、P3.3口的十六进制表示方法，用来实现按钮的控制。</p>
<div class="note primary">
            <p>关于P3口：</p><ul><li>P3.0 ==&gt; 0xfe  ==&gt;1111 1110</li><li>P3.1 ==&gt; 0xfd  ==&gt;1111 1101</li><li>P3.2 ==&gt; 0xfb  ==&gt;1111 1011</li><li>P3.3 ==&gt; 0xf7  ==&gt;1111 0111</li><li>……</li></ul><p>关于共阴极数码管的数值表可以参考 <strong>单片机-作业3</strong> <strong><a href="/undefined/acec2d97.html" title="小结">小结</a></strong></p>
          </div>


]]></content>
      <categories>
        <category>嵌入式</category>
        <category>C51单片机</category>
      </categories>
      <tags>
        <tag>C51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>【C51单片机】（三）共阳极LED数码管实现0-9显示</title>
    <url>/undefined/acec2d97.html</url>
    <content><![CDATA[<h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><p>P1接一个共阳极的LED数码管，实现显示 0 - 9</p>
<a id="more"></a>



<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt;  //包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span> <span class="comment">//延时函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;time;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//共阳极数码管0-9显示数值表</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> code dofly_table[<span class="number">10</span>]=&#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,<span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> k;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			P1=dofly_table[k];</span><br><span class="line">			<span class="built_in">delay</span>(<span class="number">40</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="仿真演示"><a href="#仿真演示" class="headerlink" title="仿真演示"></a>仿真演示</h2><img src="https://img.imgdb.cn/item/604c63dd5aedab222c3b77b7.gif" style="zoom: 60%;">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这次实验很简单，只要了解了数码管的数值表就可以通过简单的循环函数实现 0 - 9 的显示。</p>
<p>下面附上共阴极和共阳极数码管的数值表：</p>
<img src="https://img.imgdb.cn/item/604c69445aedab222c3ff100.png" style="zoom: 50%;">]]></content>
      <categories>
        <category>嵌入式</category>
        <category>C51单片机</category>
      </categories>
      <tags>
        <tag>C51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>自建frp内网穿透，实现非局域网远程windows</title>
    <url>/undefined/773c1282.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在计算机网络的课上，留意到老师都是通过远程连接来将办公室的电脑和教室的电脑进行连接，我很好奇！刚好之前我的树莓派就是通过VNC远程连接来实现桌面连接，所以就想折腾下Windows的远程连接。其实并不难，在局域网内，通过 <strong>Win + R</strong> 输入  <code>mstsc</code> 打开Windows远程桌面程序，输入局域网内想要连接的电脑的IP，然后输入密码就可以连接到另一台电脑上。</p>
<p>当然这是需要前期准备工作的，比较老的系统，如Win7打开远程桌面服务比较麻烦，如果没有密码还需要设置密码，当然没有密码也可以远程登录啦，直接回车回车… 而Win10就很方便，现在最新的Win10系统设置的UI界面越来越扁平化，直接就可以找到远程桌面这一项，一键开启即可！具体如何开启远程可以找度娘。</p>
<p>回归正题，当我不在局域内，又想远程访问远在天边的电脑，该怎么办呢，这时就有了这篇折腾frp非局域网下实现Windows远程的文章～～～</p>
<p><img src="https://img.imgdb.cn/item/604b8d1d5aedab222cee6f0e.png" alt></p>
<a id="more"></a>



<div class="note warning">
            <p>因作者学业繁忙，没能及时完成这篇文章，在填坑本文的时候已经隔了很多时间，后面的步骤可能会有些紊乱，请谅解。待后期有机会再做一次这项工程时，我会同步更新本文，并附上相应的截图。</p>
          </div>



<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul>
<li>一台VPS公网服务器</li>
<li>开启端口</li>
<li>Github下载相关文件<ul>
<li>Github内搜索frp，进入开源项目后找到releases</li>
</ul>
</li>
</ul>
<h2 id="放开端口"><a href="#放开端口" class="headerlink" title="放开端口"></a>放开端口</h2><p>因为我的服务器是腾讯云的，以腾讯云为例(放通6000，7000端口)<br><img src="https://pic.downk.cc/item/5fd864313ffa7d37b3c76f23.png" style="zoom: 50%;"></p>
<h3 id="SSH连接服务器"><a href="#SSH连接服务器" class="headerlink" title="SSH连接服务器"></a>SSH连接服务器</h3><p>安全组放开后只是能去这两个端口，服务器的这两个端口还是没有打开，所以得通过命令打开服务器的这两个端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=6000/tcp --&gt;开启6000端口</span><br><span class="line">firewall-cmd --permanent --add-port=7000/tcp --&gt;开启7000端口</span><br><span class="line">firewall-cmd --reload --&gt;重启firewall让修改的配置生效</span><br><span class="line">firewall-cmd --query-port=6000/tcp --&gt;查看6000端口是否开启</span><br><span class="line">firewall-cmd --query-port=000/tcp --&gt;查看7000端口是否开启</span><br></pre></td></tr></table></figure>
<blockquote>
<p>出现success 或 yes 字样时即为开启成功</p>
</blockquote>
<h2 id="frp下载"><a href="#frp下载" class="headerlink" title="frp下载"></a>frp下载</h2><p>传送门:<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a></p>
<p>amd64为64位使用，386是32位使用,选择对应版本下载。下载的包可以通过宝塔上传并解压到服务器的根目录下。也可以通过Linux指令进行下载和解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.34.3/frp_0.34.3_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf frp_0.34.3_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p>下载完成后，在命令行中可以看到 <strong>frp_0.34.3_linux_amd64</strong> 文件夹，我们cd一下进入该文件夹中，可以看到 <strong>frpc、frpc_full.ini、frpc.ini、frps、frps_full.ini、frps.ini、LICENSE、systemd</strong> 这几个文件，其中 <strong>frpc、frpc.ini</strong> 这个两个是客户端的文件，可以通过Linux指令删除（frpc_full.ini这个可能也是客户端文件，具体功能我还没有仔细了解，我没有删除这个文件）。</p>
<h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><blockquote>
<p>frpc —&gt; 字面上可以看出是frp client，也就是客户端<br>frps —&gt; 即frp server，也就是服务器<br>接下来我们需要修改配置文件，也就是<strong>frps.ini</strong>，按个人喜好用vi或者nano指令进行编辑；来看一下我这里的服务器端的配制文件：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//服务器端配置</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">token = aaabbbccc //这里就是客户端与我们服务器端frp进行链接时的密码，越复杂越好</span><br></pre></td></tr></table></figure>
<p>配置完成后，输入指令：<br><code>./frps -c ./frps.ini  ---&gt;服务端启动frp</code><br>可以看到提示start frps success（frps开启成功）</p>
<h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>在客户端机子下载相应的frp文件，以我的电脑为例（Windows 10）：<code>frp_0.34.3_windows_amd64</code> （注意客户端和服务器端版本要对应），文件夹可以放到任意盘，进入文件夹配置<strong>frpc.ini</strong>，Windows系统可以用记事本打开进行配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//客户端配置</span><br><span class="line">[common]</span><br><span class="line">server_addr = ***.***.*** //你的域名或IP</span><br><span class="line">server_port = 7000 //这个就是指我们在服务器端监听我们客户端的端口号与上面保持一致</span><br><span class="line">token = aaabbbccc //这个就是我们服务器端设置的密码要保持一致不然会无法连接</span><br><span class="line"></span><br><span class="line">[rdp]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389</span><br><span class="line">remote_port = 6000</span><br></pre></td></tr></table></figure>
<p>配置好保存退出后，在这个文件夹中 <strong>按住Shift + 右单击</strong>，在下拉菜单栏中单击 <strong>在此处打开PowerShell窗口</strong> ，输入指令 ：<code>.\frpc.exe -c .\frpc.ini</code> ，当出现success字样的时候就表示已经成功连接到服务器了。</p>
<div class="note info">
            <p>这里注意一下，windows一般为反斜杠 \  ，所以输入的指令不是 ./frpc.exe -c ./frpc.ini</p>
          </div>


<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>frp服务搭建成功后先别急着高兴，还有一些小问题需要解决。虽然服务器上还可以运行，但一旦我们断开ssh，我们建立的frps进程也会被kill，这时就要用到一个工具 —&gt; screen </p>
<h3 id="安装screen服务"><a href="#安装screen服务" class="headerlink" title="安装screen服务"></a>安装screen服务</h3><p><code>yum install screen -y</code></p>
<p>安装完成后，用screen新建一个会话，在这里面运行frps，退出ssh后它也不会结束进程：<br><code>screen -S frp</code></p>
<p>新建完成之后输入 <code>nohup ./frps -c ./frps.ini -&amp;</code> ，nohup是让它后台运行，-&amp;是锁定它不让它结束进程，此时即使断开了ssh我们仍可以进行连接，除非服务器重启…</p>
<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><p>如果出现无法连接的问题，有可能是需要关闭防火墙输入以下指令即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">//or</span><br><span class="line">systemctl stop iptables</span><br><span class="line">systemctl disable iptables</span><br></pre></td></tr></table></figure>
<h2 id="非局域网远程连接Windows"><a href="#非局域网远程连接Windows" class="headerlink" title="非局域网远程连接Windows"></a>非局域网远程连接Windows</h2><p>所有配置工作都做完后我们就可以进行远程连接了，在另一台计算机上 Win + R 后输入<code>mstsc</code>进入Windows远程桌面，输入服务器IP后点击连接，然后成功输入Windows密码，即可成功连接到自己的电脑。在移动端远程也是可以实现的，例如我会使用iPad对我的电脑进行远程，只需下载微软官方软件 <strong>RD Client</strong>，同样输入相关IP和密码后就可以实现移动端远程。</p>
<div class="note info">
            <p>注意</p><ul><li>两台设备需在非同一网络下进行实验</li><li>需要使用该服务时，服务器和客户端都必须打开fps服务，任何一方服务停止都无法连接成功</li><li>服务器端一般是已经配置好可以不用动了，客户端如上述打开服务出现success字样即可</li></ul>
          </div>
]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>双线部署 Coding Pages 和 GitHub Pages 并实现全站 HPPTS</title>
    <url>/undefined/f82c66a5.html</url>
    <content><![CDATA[<p>以前我的静态站是双线部署在Github Page 和 Gitee Page 上的，域名是指向Github上的所以每次访问我的静态站速度都很头疼，Gitee Page 服务每次都需要手动更新部署，而且部署速度有时也挺慢的，所以前段时间是想渐渐退出静态站的，直到后来我发现了 Coding Page 可以免费自动更新部署，而且在国内的访问速度也非常可观，让我重新燃起继续完善静态站的想法！</p>
<p>Coding Page 服务还可以绑定自己的域名（包括国外服务商购买的域名），这服务这么香，赶紧搞起来吧 o(*≧▽≦)ツ ～</p>
<a id="more"></a>

<h2 id="创建Coding项目"><a href="#创建Coding项目" class="headerlink" title="创建Coding项目"></a>创建Coding项目</h2><p>1、创建一个Coding的账号。现在的Coding是以团队的方式加入，身边没有Coding团队的小伙伴可以自己创建一个团队，身边有人有团队的话可以申请加入，这样就可以省去创建团队的功夫啦。</p>
<p>2、账号创建好后，找到 <strong>个人账户设置</strong> ，将本地生成的SSH公钥添加进去。（同Github上的设置）一般公钥路径在 <code>C:\Users\用户名\.ssh</code> 目录下的 <code>id_rsa.pub</code> 文件里，用记事本打开，将所有内容复制出来即可。</p>
<p>3、<strong>实名认证。</strong> 必须实名认证才可以设置部署静态网站。</p>
<p>4、创建一个托管静态页面的项目</p>
<ul>
<li><p>选择代码托管项目（或选择DevOps项目）</p>
<img src="https://pic.downk.cc/item/5f4a03a9160a154a67001905.png" style="zoom: 55%;">
</li>
<li><p>项目名称建议是使用自己在Coding上设置的用户名</p>
</li>
<li><p>进入刚创建的仓库，复制SSH的路径（据说SSH比较稳定）</p>
</li>
</ul>
<h2 id="配置到Hexo并部署到Coding"><a href="#配置到Hexo并部署到Coding" class="headerlink" title="配置到Hexo并部署到Coding"></a>配置到Hexo并部署到Coding</h2><p>1、配置主站目录下的 <code>_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: (自己的SSH)</span><br><span class="line">    coding: (自己的SSH)</span><br><span class="line">    #gitee: (自己的SSH)</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>2、执行三件套指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure>

<p>3、部署到Coding</p>
<ul>
<li><p>打开持续部署开关</p>
<img src="https://pic.downk.cc/item/5f4a076c160a154a6701391a.png" style="zoom: 50%">
</li>
<li><p>部署静态网站</p>
<img src="https://pic.downk.cc/item/5f4a08d0160a154a67019f6a.png">

</li>
</ul>
<p>部署完成后点开上面的访问地址可以打开你的Hexo博客说明已经部署成功啦</p>
<h2 id="添加自定义域名"><a href="#添加自定义域名" class="headerlink" title="添加自定义域名"></a>添加自定义域名</h2><p>首先需要拥有一个域名，国内购买的域名需要进行备案，国外域名商购买的域名可以不进行备案</p>
<p>本站域名是在国外域名平台 Namesilo 购买，是目前价格较便宜的域名平台，支持支付宝，提供免费的域名隐私保护，性价比较高。</p>
<blockquote>
<p>关于Namesilo域名购买可以查找度娘或者看以下这篇文章：</p>
<p><a href="https://tding.top/archives/b48e2719.html" target="_blank" rel="noopener">https://tding.top/archives/b48e2719.html</a></p>
</blockquote>
<p>域名解析我使用的是DNSPod</p>
<h3 id="添加解析记录"><a href="#添加解析记录" class="headerlink" title="添加解析记录"></a>添加解析记录</h3><p>1、ping一下Coding给你Hexo项目部署到的地址，获得Coding Page 的IP地址</p>
<p>2、在DNSPod中添加两条解析记录：</p>
<ul>
<li>记录类型为 <code>A</code> ，主机记录为 <code>@</code> ，解析线路选择默认，记录值为ping到的Coding Page的IP地址</li>
<li>记录类型为 <code>CNAME</code> ，主机记录为 <code>www</code> ，解析线路选择默认，记录值为Coding给你Hexo项目部署到的地址，例如我的是<code>https://f4kp1l.coding-pages.com</code> </li>
</ul>
<p>3、将Github的解析线路选择国外，这样就可以确保国内访问都是走Coding这边</p>
<p>具体如下图：</p>
<img src="https://pic.downk.cc/item/5f4a0db2160a154a67036573.png">

<h3 id="绑定自定义域名"><a href="#绑定自定义域名" class="headerlink" title="绑定自定义域名"></a>绑定自定义域名</h3><p>在Coding的项目中，找到 <code>持续部署→静态网站→设置</code> ，拉到下面的自定义域名，绑定新域名</p>
<img src="https://pic.downk.cc/item/5f4a0edf160a154a6703d6c8.png">

<div class="note warning">
            <p>Tips：注意：一定要选首选的域名，并且<strong>非首选域名要勾选跳转至首选域名</strong> </p>
          </div>

<h3 id="开启HTTPS"><a href="#开启HTTPS" class="headerlink" title="开启HTTPS"></a>开启HTTPS</h3><p>打开强制HTTPS开关会自动申请证书，如果你之前已经部署到了 GitHub Pages 并开启了 HTTPS，那么直接在设置页面绑定你自己的域名，SSL/TLS 安全证书就会显示申请错误。</p>
<p>申请错误原因是：在验证域名所有权时会定位到 Github Pages 的主机上导致 SSL 证书申请失败。</p>
<p><strong>正确的做法是：先去域名 DNS 把 GitHub 的解析暂停掉，然后再重新申请 SSL 证书，大约十秒左右就能申请成功，然后开启强制 HTTPS 访问</strong>。</p>
<div class="note default">
            <h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://tding.top/archives/e09249d2.html" target="_blank" rel="noopener">Hexo 博客部署到 Coding</a></p><h3 id="动态站文章地址"><a href="#动态站文章地址" class="headerlink" title="动态站文章地址"></a>动态站文章地址</h3><p><a href="https://haozsky.top/archives/14/" target="_blank" rel="noopener">https://haozsky.top/archives/14/</a><br>欢迎光临我的<a href="https://haozsky.top" target="_blank" rel="noopener">动态站</a></p>
          </div>]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>博客颜色字体用法整理</title>
    <url>/undefined/66da368c.html</url>
    <content><![CDATA[<p>在写文章的时候为了让某些内容更醒目，除了想到<strong>加粗</strong>、<code>添加代码条</code>、引用内容…之外，还可以通过改变字体颜色来突显不同。当然啦，在博客美化中也常会在很多地方会用到颜色，而每种颜色都对应着相应的色号？咳咳不对，我想说的是十六进制值，但是颜色有好几百上千种，我们又记不得这么多代码，去搜查还会浪费很多宝贵时间，真的是脑壳疼……前两天看到的一篇相关内容的文章，在这里给自己整理一下以后就不用花太多时间去找了</p>
<img src="https://pic.downk.cc/item/5f42c7fd160a154a6797f062.jpg" style="zoom: 40%;">



<a id="more"></a>

<h3 id="1、代码示例"><a href="#1、代码示例" class="headerlink" title="1、代码示例"></a>1、代码示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在Hexo中：</span><br><span class="line">&lt;font color&#x3D;&quot;red&quot;&gt;这里是红色&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">在Typecho中：</span><br><span class="line">!!!</span><br><span class="line">&lt;font color&#x3D;&quot;red&quot;&gt;这里是红色&lt;&#x2F;font&gt;</span><br><span class="line">!!!</span><br></pre></td></tr></table></figure>

<p><strong>效果：</strong><br><font color="red">这里是红色</font></p>
<ul>
<li>在Hexo中不用输入!，否则会直接输出! ；在Typecho中需要!，否则无法显示颜色</li>
</ul>
<h3 id="2、HTML5-CSS3颜色十六进制值演示站"><a href="#2、HTML5-CSS3颜色十六进制值演示站" class="headerlink" title="2、HTML5 CSS3颜色十六进制值演示站"></a>2、HTML5 CSS3颜色十六进制值演示站</h3><p>DEMO演示站：<a href="http://colors.cchosts.cn/" target="_blank" rel="noopener">http://colors.cchosts.cn/</a></p>
<h3 id="3、color颜色代码大全："><a href="#3、color颜色代码大全：" class="headerlink" title="3、color颜色代码大全："></a>3、color颜色代码大全：</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">颜色名称</th>
<th align="center">对应代码</th>
<th align="center">序号</th>
<th align="center">颜色名称</th>
<th align="center">对应代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">白颜色(<font color="#FFFFFF">例</font>)</td>
<td align="center">#FFFFFF</td>
<td align="center">11</td>
<td align="center">蓝紫色(<font color="#9F5F9F">例</font>)</td>
<td align="center">#9F5F9F</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">红颜色(<font color="#FF0000">例</font>)</td>
<td align="center">#FF0000</td>
<td align="center">12</td>
<td align="center">黄铜色(<font color="#B5A642">例</font>)</td>
<td align="center">#B5A642</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">绿颜色(<font color="#00FF00">例</font>)</td>
<td align="center">#00FF00</td>
<td align="center">13</td>
<td align="center">亮金色(<font color="#D9D919">例</font>)</td>
<td align="center">#D9D919</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">蓝颜色(<font color="#0000FF">例</font>)</td>
<td align="center">#0000FF</td>
<td align="center">14</td>
<td align="center">棕色(<font color="#A67D3D">例</font>)</td>
<td align="center">#A67D3D</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">牡丹红(<font color="#FF00FF">例</font>)</td>
<td align="center">#FF00FF</td>
<td align="center">15</td>
<td align="center">青铜色(<font color="#8C7853">例</font>)</td>
<td align="center">#8C7853</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">青颜色(<font color="#00FFFF">例</font>)</td>
<td align="center">#00FFFF</td>
<td align="center">16</td>
<td align="center">2号青铜色(<font color="#A67D3D">例</font>)</td>
<td align="center">#A67D3D</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">黄颜色(<font color="#FFFF00">例</font>)</td>
<td align="center">#FFFF00</td>
<td align="center">17</td>
<td align="center">士官服蓝色(<font color="#5F9F9F">例</font>)</td>
<td align="center">#5F9F9F</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">黑颜色(<font color="#000000">例</font>)</td>
<td align="center">#000000</td>
<td align="center">18</td>
<td align="center">冷铜色(<font color="#98719">例</font>)</td>
<td align="center">#D98719</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">海颜蓝(<font color="#70DB93">例</font>)</td>
<td align="center">#70DB93</td>
<td align="center">19</td>
<td align="center">铜色(<font color="#B87333">例</font>)</td>
<td align="center">#B87333</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">巧克力色(<font color="#5C3317">例</font>)</td>
<td align="center">#5C3317</td>
<td align="center">20</td>
<td align="center">珊瑚红(<font color="#BFF7F00">例</font>)</td>
<td align="center">#FF7F00</td>
</tr>
</tbody></table>
<hr>
<p>例色工程量有点大，后面暂时不添加例色</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">颜色名称</th>
<th align="center">对应代码</th>
<th align="center">序号</th>
<th align="center">颜色名称</th>
<th align="center">对应代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">21</td>
<td align="center">紫蓝色</td>
<td align="center">#42426F</td>
<td align="center">31</td>
<td align="center">深绿松石色</td>
<td align="center">#7093DB</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">深棕</td>
<td align="center">#5C4033</td>
<td align="center">32</td>
<td align="center">暗木色</td>
<td align="center">#855E42</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center">深绿</td>
<td align="center">#2F4F2F</td>
<td align="center">33</td>
<td align="center">淡灰色</td>
<td align="center">#545454</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">深铜绿色</td>
<td align="center">#4A766E</td>
<td align="center">34</td>
<td align="center">土灰玫瑰红色</td>
<td align="center">#856363</td>
</tr>
<tr>
<td align="center">25</td>
<td align="center">深橄榄绿</td>
<td align="center">#4F4F2F</td>
<td align="center">35</td>
<td align="center">长石色</td>
<td align="center">#D19275</td>
</tr>
<tr>
<td align="center">26</td>
<td align="center">深兰花色</td>
<td align="center">#9932CD</td>
<td align="center">36</td>
<td align="center">火砖色</td>
<td align="center">#8E2323</td>
</tr>
<tr>
<td align="center">27</td>
<td align="center">深紫色</td>
<td align="center">#871F78</td>
<td align="center">37</td>
<td align="center">森林绿</td>
<td align="center">#238E23</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center">深石板蓝</td>
<td align="center">#6B238E</td>
<td align="center">38</td>
<td align="center">金色</td>
<td align="center">#CD7F32</td>
</tr>
<tr>
<td align="center">29</td>
<td align="center">深铅灰色</td>
<td align="center">#2F4F4F</td>
<td align="center">39</td>
<td align="center">鲜黄色</td>
<td align="center">#DBDB7</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">深棕褐色</td>
<td align="center">#97694F</td>
<td align="center">40</td>
<td align="center">浅木色</td>
<td align="center">#E9C2A6</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">颜色名称</th>
<th align="center">对应代码</th>
<th align="center">序号</th>
<th align="center">颜色名称</th>
<th align="center">对应代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">41</td>
<td align="center">石灰绿色</td>
<td align="center">#32CD32</td>
<td align="center">51</td>
<td align="center">中春绿色</td>
<td align="center">#7FFF00</td>
</tr>
<tr>
<td align="center">42</td>
<td align="center">桔黄色</td>
<td align="center">#E47833</td>
<td align="center">52</td>
<td align="center">中绿松石色</td>
<td align="center">#70DBDB</td>
</tr>
<tr>
<td align="center">43</td>
<td align="center">褐红色</td>
<td align="center">#8E236B</td>
<td align="center">53</td>
<td align="center">中紫红色</td>
<td align="center">#DB7093</td>
</tr>
<tr>
<td align="center">44</td>
<td align="center">中海蓝色</td>
<td align="center">#32CD99</td>
<td align="center">54</td>
<td align="center">中木色</td>
<td align="center">#A68064</td>
</tr>
<tr>
<td align="center">45</td>
<td align="center">中蓝色</td>
<td align="center">#3232CD</td>
<td align="center">55</td>
<td align="center">深藏青色</td>
<td align="center">#2F2F4F</td>
</tr>
<tr>
<td align="center">46</td>
<td align="center">中森林绿</td>
<td align="center">#6B8E23</td>
<td align="center">56</td>
<td align="center">海军蓝</td>
<td align="center">#23238E</td>
</tr>
<tr>
<td align="center">47</td>
<td align="center">中鲜黄色</td>
<td align="center">#EAEAAE</td>
<td align="center">57</td>
<td align="center">霓虹篮</td>
<td align="center">#4D4DFF</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">中兰花色</td>
<td align="center">#9370DB</td>
<td align="center">58</td>
<td align="center">霓虹粉红</td>
<td align="center">#FF6EC7</td>
</tr>
<tr>
<td align="center">49</td>
<td align="center">中海绿色</td>
<td align="center">#426F42</td>
<td align="center">59</td>
<td align="center">新深藏青色</td>
<td align="center">#00009C</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">中石板蓝色</td>
<td align="center">#7F00FF</td>
<td align="center">60</td>
<td align="center">新棕褐色</td>
<td align="center">#EBC79E</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">颜色名称</th>
<th align="center">对应代码</th>
<th align="center">序号</th>
<th align="center">颜色名称</th>
<th align="center">对应代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">61</td>
<td align="center">暗金黄色</td>
<td align="center">#CFB53B</td>
<td align="center">71</td>
<td align="center">猩红色</td>
<td align="center">#BC1717</td>
</tr>
<tr>
<td align="center">62</td>
<td align="center">橙色</td>
<td align="center">#FF7F00</td>
<td align="center">72</td>
<td align="center">海绿色</td>
<td align="center">#238E68</td>
</tr>
<tr>
<td align="center">63</td>
<td align="center">橙红色</td>
<td align="center">#FF2400</td>
<td align="center">73</td>
<td align="center">半甜巧克力色</td>
<td align="center">#6B4226</td>
</tr>
<tr>
<td align="center">64</td>
<td align="center">淡紫色</td>
<td align="center">#DB70DB</td>
<td align="center">74</td>
<td align="center">赭色</td>
<td align="center">#8E6B23</td>
</tr>
<tr>
<td align="center">65</td>
<td align="center">浅绿色</td>
<td align="center">#8FBC8F</td>
<td align="center">75</td>
<td align="center">银色</td>
<td align="center">#E6E8FA</td>
</tr>
<tr>
<td align="center">66</td>
<td align="center">粉红色</td>
<td align="center">#BC8F8F</td>
<td align="center">76</td>
<td align="center">天蓝</td>
<td align="center">#3299CC</td>
</tr>
<tr>
<td align="center">67</td>
<td align="center">李子色</td>
<td align="center">#EAADEA</td>
<td align="center">77</td>
<td align="center">石板蓝</td>
<td align="center">#007FFF</td>
</tr>
<tr>
<td align="center">68</td>
<td align="center">石英色</td>
<td align="center">#D9D9F3</td>
<td align="center">78</td>
<td align="center">艳粉红色</td>
<td align="center">#FF1CAE</td>
</tr>
<tr>
<td align="center">69</td>
<td align="center">艳蓝色</td>
<td align="center">#5959AB</td>
<td align="center">79</td>
<td align="center">春绿色</td>
<td align="center">#00FF7F</td>
</tr>
<tr>
<td align="center">70</td>
<td align="center">鲑鱼色</td>
<td align="center">#6F4242</td>
<td align="center">80</td>
<td align="center">钢蓝色</td>
<td align="center">#236B8E</td>
</tr>
</tbody></table>
<hr>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">颜色名称</th>
<th align="center">对应代码</th>
<th align="center">序号</th>
<th align="center">颜色名称</th>
<th align="center">对应代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">81</td>
<td align="center">亮天蓝色</td>
<td align="center">#38B0DE</td>
<td align="center">86</td>
<td align="center">淡浅灰色</td>
<td align="center">#CDCDCD</td>
</tr>
<tr>
<td align="center">82</td>
<td align="center">棕褐色</td>
<td align="center">#DB9370</td>
<td align="center">87</td>
<td align="center">紫罗兰色</td>
<td align="center">#4F2F4F</td>
</tr>
<tr>
<td align="center">83</td>
<td align="center">紫红色</td>
<td align="center">#D8BFD8</td>
<td align="center">88</td>
<td align="center">紫罗兰红色</td>
<td align="center">#CC3299</td>
</tr>
<tr>
<td align="center">84</td>
<td align="center">石板蓝色</td>
<td align="center">#ADEAEA</td>
<td align="center">89</td>
<td align="center">麦黄色</td>
<td align="center">#D8D8BF</td>
</tr>
<tr>
<td align="center">85</td>
<td align="center">浓深棕色</td>
<td align="center">#5C4033</td>
<td align="center">90</td>
<td align="center">黄绿色</td>
<td align="center">#99CC</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo发布文章报错can not read a block mapping entry</title>
    <url>/undefined/6df7f115.html</url>
    <content><![CDATA[<p>今天在修改文章标题的时候报错了，我直接改标题没有动到下面的信息（冒号后都已空一格），但是在生成静态的时候给我反馈了如下错误：</p>
<blockquote>
<p><code>YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 2, column 4:</code></p>
</blockquote>
<p>经过Google查找发现是标题配置里面有<code>&quot; &quot;</code>和<code>( )</code>这类英文符号，导致文章无法按照正确YAML语法解析而出错，把它们改成中文符号就好了。</p>
<p>通过此次踩坑发现，文章头部配置要严格按照YAML语法来写。</p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Typecho主站崩溃与自建RSSHub和跨域服务</title>
    <url>/undefined/2dcf1105.html</url>
    <content><![CDATA[<img src="https://pic.downk.cc/item/5f3ea93814195aa594522d61.png">



<p>前几天发现我的动态主站崩溃了（2020.8.12），通过域名打开直接出现的是PHP源码，一番折腾后虽然能进主页了，但是所有子页面都无法打开，网页显示 <code>404 Not Found nginx</code> ，苦于我这嵌入式方向专业的童鞋没有前端基础折腾了好久没办法修复，只能删库重建网站了。更痛心的是数据库也因保存错误数据导致数据无法恢复了……我的头发白掉了啊(ㄒoㄒ)</p>
<p>经过和重建网站的Nginx配置对比，为什么出问题自己心里算是有些眉目了，两份Nginx配置内容有很大差别，说明是在某个时候这份配置被覆盖了，为什么会被覆盖？将在文章RSSHub和跨域服务搭建过程中说明……</p>
<a id="more"></a>

<hr>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p><strong>RSSHub：万物皆可 RSS</strong></p>
<p>RSSHub 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。RSSHub 借助于开源社区的力量快速发展中，目前已适配数百家网站的上千项内容。</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h2 id="1-利用宝塔PM2搭建RSSHub"><a href="#1-利用宝塔PM2搭建RSSHub" class="headerlink" title="1.利用宝塔PM2搭建RSSHub"></a>1.利用宝塔PM2搭建RSSHub</h2><ul>
<li><strong>RSSHub项目地址：</strong><a href="https://github.com/DIYgod/RSSHub" target="_blank" rel="noopener">DIYgod/RSSHub</a></li>
</ul>
<p>对于小白来说，宝塔面板的PM2管理器非常方便，使用云服务器建站用起来容易上手。</p>
<h3 id="1-1-clone源码到root目录下"><a href="#1-1-clone源码到root目录下" class="headerlink" title="1.1 clone源码到root目录下"></a>1.1 clone源码到root目录下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;DIYgod&#x2F;RSSHub.git</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>可能是因为RSSHub项目被墙的缘故，项目网页需要翻墙才可以打开，所以难免会出现clone速度很慢的同学，我们可以采用其他办法将源码下载出来，上传到root目录下，命名为RSSHub即可。<br>解决办法：</p><ul><li>使用代理下载速度快的同学可以直接将源码压缩包下载出来，解压并将RSSHub文件夹通过宝塔上传至root目录中</li><li>利用Gitee导入Github仓库功能，直接clone导入到Gitee仓库的RSSHub项目即可解决</li></ul>
          </div>

<h3 id="1-2-安装PM2管理器，启动RSSHub"><a href="#1-2-安装PM2管理器，启动RSSHub" class="headerlink" title="1.2 安装PM2管理器，启动RSSHub"></a>1.2 安装PM2管理器，启动RSSHub</h3><p>PM2管理器在宝塔面板软件商店中搜索找到并安装。</p>
<h4 id="启动RSSHub"><a href="#启动RSSHub" class="headerlink" title="启动RSSHub"></a>启动RSSHub</h4><ul>
<li><p><strong>命令行法添加项目</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd RSSHub</span><br><span class="line">pm2 start lib&#x2F;index.js --name rsshub</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>命令行添加法优点是添加项目速度快，但是在PM2中有可能会无法打开项目目录导致最终搭建失败</p>
</blockquote>
<ul>
<li><p><strong>PM2添加法</strong></p>
<img src="https://pic.downk.cc/item/5f3ad4a914195aa594bd99a3.png">

</li>
</ul>
<p>添加好后点击「映射」，设置域名，如图：</p>
<img src="https://pic.downk.cc/item/5f3ad5d614195aa594bdc6b5.png">

<div class="note warning">
            <ul><li>设置的域名可以到你的域名解析里添加一个子域名映射到服务器IP即可。子域名例如<code>rsshub.xxx.com</code>中的rsshub部分可随意设置</li><li>解析好子域名后顺便去申请个SSL证书，并在宝塔站点中开启子域名的SSL，如果不支持https会造成浏览器加载失败</li><li>必须映射到根目录RSSHub中，宝塔有可能会默认映射到www目录中，如果映射到www目录可能会导致覆盖Typecho网站的Nginx配置，从而使网站出现各种错误，这就是我主站崩溃的原因</li></ul>
          </div>
<p>最后在浏览器中打开<strong>你设置映射的域名(<code>https://rsshub.xxx.com</code>)</strong>看到RSSHub的图标并且显示<strong><code>Welcome to RSSHub!</code></strong>字样的页面说明搭建成功！</p>
<h3 id="2-利用宝塔Docker-部署RSSHub"><a href="#2-利用宝塔Docker-部署RSSHub" class="headerlink" title="2. 利用宝塔Docker 部署RSSHub"></a>2. 利用宝塔Docker 部署RSSHub</h3><div class="note info">
            <p>可参考<strong><a href="https://blog.dlzhang.com/" target="_blank" rel="noopener">班班</a></strong>的文章：</p><ul><li><a href="https://blog.dlzhang.com/posts/49/" target="_blank" rel="noopener">宝塔面板部署 RSSHub 和自动签到 Docker 应用</a></li></ul>
          </div>

<h3 id="3-跨域服务"><a href="#3-跨域服务" class="headerlink" title="3. 跨域服务"></a>3. 跨域服务</h3><p>跨域最简单的解决办法是：在原有的RSS源地址前面加上<code>https://cors-anywhere.herokuapp.com/</code></p>
<p>例如<code>https://cors-anywhere.herokuapp.com/https://rsshub.xxx.com/rss路由</code></p>
<p>但是这个方法访问速度比较慢，我这甚至出现了无法加载的情况，所以我们需要自己搭建一个跨域服务：</p>
<blockquote>
<p><a href="https://github.com/netnr/proxy" target="_blank" rel="noopener">proxy(HTTP请求代理，CORS跨域请求，HTTPS支持)</a></p>
</blockquote>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;netnr&#x2F;proxy.git</span><br><span class="line">cd proxy</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>如果clone不到使用，解决方法同上RSSHub，安装目录依旧是在根目录root下。</p>
<h4 id="PM2管理器添加项目"><a href="#PM2管理器添加项目" class="headerlink" title="PM2管理器添加项目"></a>PM2管理器添加项目</h4><p>添加项目同RSSHub的PM2添加法，启动文件为<strong>server.js</strong>，项目名称可随意。添加好后点击「映射」，设置域名。（这里域名需要再解析一个新的子域名并申请SSL证书，记得在宝塔添加证书开启SSL）</p>
<p>这时自己搭建的跨域服务为：<code>https://proxy.xxx.com/</code></p>
<p>此时自己的代理为：<code>https://proxy.xxx.com/https://rsshub.xxx.com/rss路由</code>，浏览器打开代理可以看到爬到的RSS源代码说明成功啦，同时可以发现自建跨域服务速度飞快（/赞）</p>
<h3 id="4-订阅RSS源"><a href="#4-订阅RSS源" class="headerlink" title="4. 订阅RSS源"></a>4. 订阅RSS源</h3><p>有了以上准备就可以订阅其他网站的RSS源啦，这里以B站为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户追番列表</span><br><span class="line">作者: @wdssmq</span><br><span class="line"></span><br><span class="line">举例: https:&#x2F;&#x2F;rsshub.app&#x2F;bilibili&#x2F;user&#x2F;bangumi&#x2F;208259</span><br><span class="line"></span><br><span class="line">路由: &#x2F;bilibili&#x2F;user&#x2F;bangumi&#x2F;:uid</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">uid, 必选 - 用户 id</span><br></pre></td></tr></table></figure>

<p>这时搭配上自建的两个服务后url就是：</p>
<p><code>https://proxy.xxx.com/https://rsshub.xxx.com/bilibili/user/bangumi/:uid</code></p>
<div class="note info">
            <ul><li>具体RSS源网站内容聚合在时光机页面内的配置可参见handsome文档</li><li>RSSHub具体的配置和路由可参见<a href="https://docs.rsshub.app/" target="_blank" rel="noopener">RSSHub文档</a>（RSSHub文档目前好像也被墙了）</li></ul>
          </div>

<blockquote>
<p>参考文章：</p>
<p><a href="https://www.anleenoxu.top/archives/156.html" target="_blank" rel="noopener">https://www.anleenoxu.top/archives/156.html</a><br><a href="https://www.jellyw.com/archives/170/" target="_blank" rel="noopener">https://www.jellyw.com/archives/170/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>Typecho</category>
      </categories>
      <tags>
        <tag>Typecho</tag>
        <tag>RSSHub</tag>
      </tags>
  </entry>
  <entry>
    <title>【Pi】VNC远程连接树莓派和WiFi模块的开启</title>
    <url>/undefined/66fbe44e.html</url>
    <content><![CDATA[<h2 id="前-言"><a href="#前-言" class="headerlink" title="前 言"></a>前 言</h2><p>前段时间在腾讯云买了台云服务器，随后又开始了解到树莓派也可以用来搭建服务器，毕竟作为技术型学生，对技术的学习总有着探索和热情之心。所以入手了一块树莓派4B（2G），打算用来搭建属于自己的服务器，同时开启了Linux学习之路(ง •̀_•́)ง……</p>
<p>今天记录一下成功用VNC进行远程连接还有成功用上WiFi功能！Ｏ(≧▽≦)Ｏ </p>
<img src="https://pic.downk.cc/item/5f27f04714195aa594f0fd43.jpg" style="zoom: 10%;" alt="正在使用的4B">

<a id="more"></a>

<h2 id="VNC远程连接"><a href="#VNC远程连接" class="headerlink" title="VNC远程连接"></a>VNC远程连接</h2><p>树莓派4B自带VNC，我们不需要再使用指令安装</p>
<ul>
<li><p>前期需要：</p>
<ul>
<li><p>树莓派的IP地址：给树莓派插上网线，在同一个内网（局域网）下，可以登录路由器管理界面查看树莓派的IP。</p>
</li>
<li><p>使用SSH远程树莓派（可以通过XShell、PuTTY或者SSH远程指令）</p>
<p><a href="https://www.cncrk.com/downinfo/236592.html" target="_blank" rel="noopener">XShell6下载 v6.0.0086 64位破解版</a>：下载地址里面用普通下载地址下载即可，高速下载器通道会附有垃圾软件。</p>
<p>SSH远程指令：<code>ssh pi@树莓派的IP地址</code></p>
</li>
<li><p>在自己的电脑上安装VNC。VNC是一款远程桌面软件，支持Windows、Mac、iOS、Linux、树莓派操作系统，而且树莓派自带VNC，只需要远程打开它就好了。</p>
<img src="https://pic.downk.cc/item/5f30963914195aa5940609ca.jpg" style="zoom: 70%;">
</li>
</ul>
</li>
<li><p>接下来是远程配置树莓派，指令为</p>
<p><code>sudo raspi-config</code></p>
<p>在终端/运行中键入以上指令后的现象如下图所示，选择步骤：5 Interfacing Options → P3 VNC → 是 → 确定 →Finish。</p>
<img src="https://pic.downk.cc/item/5f27dd9a14195aa594ea1d80.png" style="zoom: 85%;">

<p>配置完成后树莓派上的VNC就可以使用了。</p>
<p>在终端中输入指令 <code>vncserver</code> 后，等待字符跑完……然后如下图看到的，结束后最后一行的IP就是我们需要的，他告诉我们树莓派桌面的IP地址为192.168.3.20，端口号为1，有了这个我们就可以通过自己的电脑上的VNC远程树莓派了。</p>
<img src="https://pic.downk.cc/item/5f27dfe614195aa594eb17a8.png" style="zoom: 85%;">

</li>
</ul>
<p>VNC远程树莓派操作和XShell远程操作相似就不在加以叙述。</p>
<p>其实还可以通过手机或平板（ios端）对树莓派进行远程，只要在App Store中下载VNC，进行远程操作后就可以实现啦。</p>
<h2 id="开启树莓派无线上网模式"><a href="#开启树莓派无线上网模式" class="headerlink" title="开启树莓派无线上网模式"></a>开启树莓派无线上网模式</h2><p>树莓派4B内置有WiFi模块，可以不用外接无线网卡实现WiFi上网功能，下面将简单写下WiFi模块的开启。</p>
<p>在程序烧录进SD卡完成后，在boot中新建 <code>wpa_supplicant.conf</code> 文件，并写入无线的相关配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">country&#x3D;CN</span><br><span class="line">ctrl_interface&#x3D;DIR&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant GROUP&#x3D;netdev</span><br><span class="line">update_config&#x3D;1</span><br><span class="line">  </span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">    ssid&#x3D;&quot;wi-fi name here&quot;</span><br><span class="line">    psk&#x3D;&quot;wi-fi password here&quot;</span><br><span class="line">    key_mgmt&#x3D;WPA-PSK</span><br><span class="line">    priority&#x3D;1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> WiFi 配置示例说明：</p>
<ul>
<li><strong>ssid:网络的ssid</strong></li>
<li><strong>psk:密码</strong></li>
<li><strong>priority:连接优先级，数字越大优先级越高（不可以是负数）</strong></li>
</ul>
<p>如果有两个就在下面多添加一个<code>network</code>的代码并标好优先级就可。</p>
<p>若SD卡已经插入树莓派中，但又想修改文件中的内容可以使用指令来完成，在终端中输入以下指令打开文件</p>
<p><code>sudo nano  /etc/wpa_supplicant/wpa_supplicant.conf</code></p>
<p>可以用vim或nano编辑，这里使用nano，nano编辑完后先按Ctrl+O再按Enter对修改内容进行保存，再按Ctrl+X退出回到原来的终端界面。</p>
<p>以上就是这次对树莓派这块小玩意做的小总结啦~</p>
]]></content>
      <categories>
        <category>Pi</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>【C51单片机】（二）实验一升级，进阶+复习！</title>
    <url>/undefined/6e490410.html</url>
    <content><![CDATA[<h2 id="1-前情提要"><a href="#1-前情提要" class="headerlink" title="1. 前情提要"></a>1. 前情提要</h2><p>通过 <strong><a href="/undefined/ec01d655.html" title="实验一">实验一</a></strong> 我们知道，单片机（以AT89C51为例）I/O端口需要通过对应的十六进制代码来使用，通过编程每一个按钮实现的功能都不一样。嘿嘿，这期我们升级一下，通过按下两个按钮来实现他们的功能  ─=≡Σ((( つ•̀ω•́)つ Let’s go!</p>
<a id="more"></a>

<h2 id="2-实验题目"><a href="#2-实验题目" class="headerlink" title="2. 实验题目"></a>2. 实验题目</h2><p><strong>P1接8个灯，P3.2、P3.3、P3.4、P3.5接4个按钮</strong>（以实验一为基础）</p>
<p><strong>选择其中两个开关，完成按下一个开关流水灯顺着循环滚动不停，按下另一个，流水灯逆着滚动不停</strong> </p>
<p>（本次实验仅实现题目功能，其他功能观众有兴趣的话可以继续造 o(￣▽￣)o 捏嘿）</p>
<h3 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1 代码实现"></a>2.1 代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span> <span class="comment">//延时函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;time;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">		;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> y,m,n;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> a[<span class="number">8</span>]=&#123;<span class="number">0xfe</span>,<span class="number">0xfd</span>,<span class="number">0xfb</span>,<span class="number">0xf7</span>,<span class="number">0xef</span>,<span class="number">0xdf</span>,<span class="number">0xbf</span>,<span class="number">0x7f</span>&#125;;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> b[<span class="number">8</span>]=&#123;<span class="number">0x7f</span>,<span class="number">0xbf</span>,<span class="number">0xdf</span>,<span class="number">0xef</span>,<span class="number">0xf7</span>,<span class="number">0xfb</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;; <span class="comment">//a、b为顺逆流值</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> c[<span class="number">4</span>]=&#123;<span class="number">0xfb</span>,<span class="number">0xf7</span>,<span class="number">0xef</span>,<span class="number">0xdf</span>&#125;; <span class="comment">//只按一个按钮的值</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> d[<span class="number">6</span>]=&#123;<span class="number">0xf3</span>,<span class="number">0xeb</span>,<span class="number">0xdb</span>,<span class="number">0xe7</span>,<span class="number">0xd7</span>,<span class="number">0xcf</span>&#125;;  <span class="comment">//按两个按钮时的值</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">	 <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;<span class="number">4</span>;m++) <span class="comment">//当只按一个按钮时顺流</span></span><br><span class="line">	 &#123;</span><br><span class="line">		<span class="keyword">if</span>(P3==c[m])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;<span class="number">8</span>;y++)</span><br><span class="line">			 &#123;</span><br><span class="line">			  P1=a[y];</span><br><span class="line">			  <span class="built_in">delay</span>(<span class="number">20</span>);</span><br><span class="line">			 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		P1=<span class="number">0xff</span>;	</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">6</span>;n++) <span class="comment">//当按下两个按钮时逆流</span></span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">if</span>(P3==d[n])</span><br><span class="line">		 &#123;</span><br><span class="line">			<span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;<span class="number">8</span>;y++)</span><br><span class="line">			 &#123;</span><br><span class="line">			  P1=b[y];</span><br><span class="line">			  <span class="built_in">delay</span>(<span class="number">20</span>);</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">else</span></span><br><span class="line">		 P1=<span class="number">0xff</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><strong>心得体会：</strong></p>
<p>因为刚接触这门课，萌新的我花了很长时间才将题目功能实现出来QAQ。当时编写出现的问题是①按下按钮都无法实现功能和②按下一个按钮流水灯能发生顺流而按下第二个按钮或相隔的按钮时无法进行逆流，所以我认为可以从②中寻找为何按下第二个按钮或相隔按钮时无法逆流的问题。</p>
<p>当时和好友一起讨论的时候我注意到了他的一句话 <strong>“按两个按钮就是1111 0011，也就是0xf3了 ”</strong> ，因为这句话我得到了灵感，那就是把任意两个按钮同时按下时的十六进制值写数组中，这样就像只按一个按钮的数组一样。当然，顺逆流的循环可以优化一下省去一部分代码，而且我在网上找过很多方法，可能在选择按钮中会有更简便的写法。</p>
<h3 id="2-2-仿真演示"><a href="#2-2-仿真演示" class="headerlink" title="2.2 仿真演示"></a>2.2 仿真演示</h3><blockquote>
<p><em>本代码可以实现按下<strong>任意两个</strong>开关流水灯都可以进行逆流。</em></p>
</blockquote>
<ul>
<li><p>按下一个开关时：（这里以按下P3.3开关为例）</p>
<p><img src="https://pic.downk.cc/item/5f3a9dbe14195aa594b20d40.gif" alt></p>
</li>
<li><p>按下两个开关时：</p>
<p>如按下P3.3和P3.5开关：（相隔按钮）</p>
<p><img src="https://pic.downk.cc/item/5f3a9dd514195aa594b2143e.gif" alt></p>
<p>如按下P3.4和P3.5开关：（相邻按钮）</p>
<p><img src="https://pic.downk.cc/item/5f3a9de614195aa594b219ed.gif" alt></p>
</li>
</ul>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>这次实验对于实验一来说是一次升格，因为通过双开关这一步更加加深了对I/O端口的了解和运用，是流水灯实验中一道不错的综合题。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>C51单片机</category>
      </categories>
      <tags>
        <tag>C51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶之路！从0开始搭建Hexo博客（二）</title>
    <url>/undefined/91ba00fe.html</url>
    <content><![CDATA[<img src="https://1on1.today/blog/wp-content/uploads/2019/03/blog.jpg" style="zoom: 67%;">

<a id="more"></a>



<h1 id="1-Hexo安装"><a href="#1-Hexo安装" class="headerlink" title="1.Hexo安装"></a>1.Hexo安装</h1><p>接上一篇</p>
<ul>
<li><p>在Git中输入<code>npm -v</code>和<code>node -v</code>，若出现版本号说明node安装成功。输入<code>npm install hexo-cli -g</code>安装Hexo，安装完成后即可退出Git。</p>
</li>
<li><p>在任意磁盘中新建一个文件夹来放配置文件，比如在D盘中新建了一个文件夹命名为“Myblog”；打开你的文件夹，然后在空白处点鼠标的右键，选择<code>Git Bash Here</code>；在Git中输入命令<code>hexo init</code>安装相关配置。</p>
<p>等待安装完毕后，最后一句出现 <strong>INFO Start blogging with hexo</strong> 说明Hexo已经搭建成功了。</p>
</li>
<li><p>搭建完成后可输入命令 <code>npm install</code> 和 <code>npm install hexo-deployer-git --save</code> 方便今后部署。</p>
</li>
</ul>
<h1 id="2-运行测试"><a href="#2-运行测试" class="headerlink" title="2.运行测试"></a>2.运行测试</h1><p>首先介绍一下今后写博客时会经常用到的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  #用来清理缓存文件</span><br><span class="line">hexo s      #运行本地服务器</span><br><span class="line">hexo g      #生成静态文件</span><br><span class="line">hexo d      #上传到服务器</span><br></pre></td></tr></table></figure>

<p>博客搭建成功后，输入命令 <code>hexo s</code> (hexo server) 运行本地服务器</p>
<img src="https://pic.downk.cc/item/5f3aa12a14195aa594b2e384.png" style="zoom: 80%;">

<p>打开浏览器，输入<code>localhost:4000</code>，看到以下页面说明<strong>本地环境搭建完成</strong></p>
<img src="https://pic.downk.cc/item/5f3ab11014195aa594b6cf97.png" style="zoom: 60%;">



<h1 id="3-部署到云端"><a href="#3-部署到云端" class="headerlink" title="3.部署到云端"></a>3.部署到云端</h1><p>将博客部署到远端后别人才可以访问到你的网站，这里以GitHub为例。</p>
<ul>
<li><p>首先在你所建立的blog文件夹根目录下找到<strong>_config.yml</strong>也就是<strong>站点配置文件</strong>，用编辑器打开文件。打开后拉到最下面找到<strong>deploy</strong>，做以下修改：</p>
<img src="https://pic.downk.cc/item/5f3ab1d214195aa594b6fa78.png" style="zoom:80%;">

<p>地址我使用的是SSH的地址，修改完成后保存配置文件。</p>
</li>
<li><p>在Git命令输入框中输入命令<code>hexo g</code>（hexo generate）在本地生成静态文件。再次输入<code>hexo s</code>可预览是否有问题，没有问题后按<strong>Ctrl+C</strong>退出预览，输入<code>hexo d</code>就可以上传至GitHub云端啦。</p>
</li>
</ul>
<p>当然，今后写博客想要一步到位的话也可以使用一键三杀：</p>
<blockquote>
<p><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p>
<p>或 <code>hexo clean &amp;&amp; hexo g -d</code></p>
</blockquote>
<h1 id="4-更换主题"><a href="#4-更换主题" class="headerlink" title="4.更换主题"></a>4.更换主题</h1><p>Hexo的主题可以在官网的<a href="https://hexo.io/themes/" target="_blank" rel="noopener"><strong>主题</strong></a>里找到自己喜欢的主题，点击主题名可以进入到主题的GitHub地址，里面会有相关主题的安装和配置说明等。</p>
<p>主题安装完成后需要在<strong>博客的站点配置文件</strong>中找到<strong>theme:</strong>，并将其原来的landscape主题改成自己下载的主题的名字，主题名为<strong>themes文件目录</strong>中的主题文件名</p>
<img src="https://pic.downk.cc/item/5f3ab23414195aa594b70eec.png" style="zoom:70%;">

<p>这里以我用的next主题为例</p>
<p>主题更换好后再来一次<code>hexo s</code>就能预览到自己更换的主题啦。关于主题的美化大家可以自己去研究，网上关于Hexo的文章有很多，出现问题一般都比较容易找到。关于next主题美化这里推荐以下参考视频：</p>
<blockquote>
<p>UP主<a href="https://space.bilibili.com/386767453/" target="_blank" rel="noopener"><strong>dp2px_com:</strong></a></p>
<p><a href="https://www.bilibili.com/video/BV1VE411k7jP" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1VE411k7jP</a></p>
<p><a href="https://www.bilibili.com/video/BV1LE411k7SR" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1LE411k7SR</a></p>
</blockquote>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><strong>“从0开始搭建Hexo博客”系列</strong>到这里就完结了，因为搭建过程需要更直观的表达会更好些，文字工程量其实是挺大的，所以该文章主要是基于UP主的视频所写，有不懂的地方可以去看视频，里面的操作会更直观。</p>
<p>tips：</p>
<ol>
<li><p>配置文件中，冒号后（如theme:）必须要空一格才能输入东西。主题文件中也有配置文件，和站点的配置文件名字相同但是用途不同，需要注意分清楚。</p>
</li>
<li><p>关于部署方面其实有很多选择，除GitHub外，类似的还有Gitee和Coding，GitHub主要是国外的所以可能会导致别人的访问速度方面的体验跟不上，当然像Gitee等国内的Page服务体验也会有所不同。</p>
</li>
<li><p>关于主题方面大家可以自己慢慢探索，美化主题不是一天就能完成的事，就像记单词一样，一点一点地发现和积累，最终就可以美化成为你所希望的主题。</p>
</li>
</ol>
<p>最后祝大家能够做出属于自己的博客</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>新技能加点！从0开始搭建Hexo博客（一）</title>
    <url>/undefined/80342cee.html</url>
    <content><![CDATA[<img src="https://pic1.zhimg.com/v2-0d8684079db9ede92ed46ef40b69a1e6_1200x500.jpg" style="zoom:67%;">



<a id="more"></a>

<hr>
<h4 id="特别感谢以下UP主的教学视频："><a href="#特别感谢以下UP主的教学视频：" class="headerlink" title="特别感谢以下UP主的教学视频："></a>特别感谢以下UP主的教学视频：</h4><p><strong><font size="4">①<a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener">CodeSheep</a>:</font></strong></p>
<p>传送门：<a href="https://www.bilibili.com/video/BV1Yb411a7ty" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411a7ty</a></p>
<p><strong><font size="4">②<a href="https://space.bilibili.com/100518197/" target="_blank" rel="noopener">Master_lisa</a>:</font></strong></p>
<p>传送门：<a href="https://www.bilibili.com/video/BV1A4411G7SF" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1A4411G7SF</a></p>
<hr>
<p><strong>前情提要：</strong>我的搭建系统是windows 10，流程根据UP主Master_lisa的视频来写。OK,Here we go！</p>
<h2 id="1-提前准备"><a href="#1-提前准备" class="headerlink" title="1.提前准备"></a>1.提前准备</h2><ul>
<li><p><strong>创建Github/Gitee(码云)：</strong></p>
<p>用户名都是最好用小写字母，可以加数字。创建好后点击网页右上角+号创建新库，如下图：</p>
<p><img src="https://pic.downk.cc/item/5f3a9e2a14195aa594b22af7.png" alt></p>
<p>新建库时应严格按照①中用户名，以这种<code>xxx.github.io</code>形式(②)输入：<img src="https://pic.downk.cc/item/5f3a9e4b14195aa594b2315a.png" alt></p>
<p>输入完毕后点击下方绿色按钮<strong>Create repository</strong>就完成建库啦。</p>
</li>
<li><p><strong>安装 <a href="https://nodejs.org" target="_blank" rel="noopener">Node.js</a>：</strong><code>https://nodejs.org</code></p>
<p><img src="https://pic.downk.cc/item/5f3a9e6414195aa594b23695.png" alt></p>
<p>安装步骤很简单，一直next，默认安装就行。</p>
</li>
<li><p><strong>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>：</strong><code>https://git-scm.com/downloads</code></p>
<p><img src="https://pic.downk.cc/item/5f3a9e7614195aa594b23b43.png" alt></p>
<p><img src="https://pic.downk.cc/item/5f3a9e8614195aa594b23f16.png" alt></p>
<p>安装步骤也是一直点下一步，按官方默认的来装就行。（路径可选）</p>
<blockquote>
<p>tips：Git安装完成后，发现右键有Git的功能快捷键，我们主要用Git Bash。</p>
</blockquote>
</li>
</ul>
<h2 id="2-配置Git"><a href="#2-配置Git" class="headerlink" title="2.配置Git"></a>2.配置Git</h2><p>在Git安装目录下右键点击<code>Git Bash Here</code>，在终端窗口配置好你的用户名和邮箱：</p>
<blockquote>
<p><code>$ git config --global user.name &quot;John Doe&quot;</code>（“John Doe”为你要输入的用户名）</p>
<p><code>$ git config --global user.email &quot;johndoe@example.com&quot;</code>（email后填你的邮箱）</p>
</blockquote>
<p>配置好后可以输入以下检查是否配置成功，如果输出结果是你输入的东西就是配置成功了：</p>
<blockquote>
<p><code>$ git config --global user.name</code></p>
<p><code>$ git config --global user.email</code></p>
</blockquote>
<p>tips：以上只需复制$符号之后的代码即可；在Git中复制粘贴不能使用ctrl+c/v，只能老老实实用鼠标。</p>
<h2 id="3-配置SSH"><a href="#3-配置SSH" class="headerlink" title="3.配置SSH"></a>3.配置SSH</h2><ul>
<li><p>继续在终端窗口输入：<code>ssh-keygen -t rsa -C &quot;johndoe@example.com&quot;</code>，在接下来全部按回车键，出现选项选y然后继续回车。出现下图样式说明成功：</p>
<p><img src="https://pic.downk.cc/item/5f3a9e9814195aa594b243a9.png" alt></p>
<p>这时可以按配置里说的public key的地址去找到自己的ssh公钥。一般在<code>C:\Users\Admin</code>中出现<code>.ssh</code>文件夹，右击该文件夹里的<code>id_rsa.pub</code>以记事本形式打开，里面就是你的SSH公钥。</p>
</li>
<li><p>将SSH配置到Github上。在Github上点击<strong>头像</strong>，找到<strong>Settings</strong>点击进入，找到左栏的<strong>SSH and GPG keys</strong>。然后点击<strong>New SSH key</strong>。</p>
<p><img src="https://pic.downk.cc/item/5f3a9eaf14195aa594b24a55.png" alt></p>
</li>
<li><p>输入以下检验是否配置成功：</p>
<blockquote>
<p><code>$ ssh git@github.com</code></p>
<p><code>$ ssh -T git@github.com</code></p>
</blockquote>
<p>若都出现<strong>You’ve successfully authenticated</strong>字样就是配置成功了。</p>
</li>
</ul>
<hr>
<p><strong>←To Be Continued</strong></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【C51单片机】（一）4个按钮8盏灯，实现四种功能</title>
    <url>/undefined/ec01d655.html</url>
    <content><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>文章主要分享本人的单片机学习过程，包含：课题、代码、程序仿真以及个人向的理解和推荐（不够专业，望理解）。希望能够对大家有帮助。</p>
<h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><p><strong>P1接8个灯，P3.2、 P3.3、 P3.4、P3.5接4个按钮，</strong><br><strong>按下P3.2 P1的8个灯奇亮偶不亮；</strong><br><strong>按下P3.3 P1的8个灯偶量奇不亮；</strong><br><strong>按下P3.4 P1的8个灯流水灯顺着滚动遍；</strong><br><strong>按下P3.5 P1的8个灯流水灯倒着滚动一遍。</strong></p>
<p><strong>编写程序实现以上功能。</strong></p>
<a id="more"></a>

<ol>
<li><p>首先根据题目发现使用到的I/O端口为P1和P3，注意8个灯接P1.0-1.7,4个按钮接P3.2-3.5。灯的问题由十六进制代码实现。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span><span class="comment">//延时函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> i,j;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;time;i++)</span><br><span class="line"> <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> y;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> a[<span class="number">8</span>]=&#123;<span class="number">0xfe</span>,<span class="number">0xfd</span>,<span class="number">0xfb</span>,<span class="number">0xf7</span>,<span class="number">0xef</span>,<span class="number">0xdf</span>,<span class="number">0xbf</span>,<span class="number">0x7f</span>&#125;;<span class="comment">//流水灯P1口的值</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> b[<span class="number">8</span>]=&#123;<span class="number">0x7f</span>,<span class="number">0xbf</span>,<span class="number">0xdf</span>,<span class="number">0xef</span>,<span class="number">0xf7</span>,<span class="number">0xfb</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(P3==<span class="number">0xfb</span>)   <span class="comment">//按下P3.2 P1的8个灯奇亮偶不亮</span></span><br><span class="line">    P1=<span class="number">0xaa</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(P3==<span class="number">0xf7</span>)   <span class="comment">//按下P3.3 P1的8个灯偶亮奇不亮</span></span><br><span class="line">  	P1=<span class="number">0x55</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(P3==<span class="number">0xef</span>)    <span class="comment">//按下P3.4 P1的8个灯流水灯顺着滚动一遍</span></span><br><span class="line">  	 <span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;<span class="number">8</span>;y++)</span><br><span class="line">         &#123;</span><br><span class="line">          P1=a[y];</span><br><span class="line">          <span class="built_in">delay</span>(<span class="number">20</span>);</span><br><span class="line">         &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(P3==<span class="number">0xdf</span>)    <span class="comment">//按下P3.5 P1的8个灯流水灯逆着滚动一遍</span></span><br><span class="line">		<span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;<span class="number">8</span>;y++)</span><br><span class="line">         &#123;</span><br><span class="line">          P1=b[y];</span><br><span class="line">          <span class="built_in">delay</span>(<span class="number">20</span>);</span><br><span class="line">         &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  P1=<span class="number">0xff</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>p.s<!--单词注释：postscript-->：此程序还可以进一步简化，关于P3.5可以使用for语句逆循环a数组里的数据，但是要注意的是需要将变量y的无符号型限制去掉才可以使用，否则会出现错误。</p>
</li>
<li><p>仿真演示：</p>
<p><img src="https://pic.downk.cc/item/5f3a9d9914195aa594b204d2.gif" alt></p>
</li>
</ol>
<p><strong>小结</strong></p>
<p>了解I/O端口以及对应的十六进制代码表示；熟悉C语言if-else和for语句，延时函数。</p>
<h2 id="使用到的软件"><a href="#使用到的软件" class="headerlink" title="使用到的软件"></a>使用到的软件</h2><ol>
<li><p><strong>代码编辑器/IDE</strong>：主要用来写C语言的代码，我比较喜欢用的是Notepad++和VS Code。这两个编写和浏览代码比较舒服，学校让我们装的是VC6.0。简单介绍一下我用过的：</p>
<ul>
<li>VC6.0：比较老了，初学者用一下可以，但是不推荐未来使用。我的使用感受是启动慢，字体小，没有编辑辅助功能，有的错误它不会提示，要自己去找。总的来说就是不够智能吧。</li>
<li>Notepad++：优秀的代码编辑器，支持超过50种编程、脚本和标记语言的语法高亮显示，代码可折叠方便查阅整个文档。轻量化的感觉，开启迅速，编写和浏览很舒服。</li>
<li>VS Code：第一次接触它是从搭建博客开始的，之前都是使用Notepad++，至于VC6.0？？？除了刚学C的时候用过，之后再没打开过。同样也是轻量级体验，支持几乎所有主流的开发语言的语法高亮和智能代码补全等。如果需要看大量代码的话这个是很推荐的，看着比较舒服；如果是单片机初学阶段，写的代码不多，个人推荐Notepad++就够了。</li>
<li>SUBLIME TEXT：这款也是因为搭建博客而接触到的编辑器。有付费内容，但是使用免费的不影响体验也没有时间限制，使用感受和VS Code差不多，同样拥有高亮显示和编辑辅助功能。和VS Code看起来我觉得SUBLIME TEXT的代码显示要Q些，看起来比较可爱哈哈哈。</li>
<li>以上就是我使用过的编辑器的简单介绍了，如果想了解得更细致些可以到google和baidu查。我们还学习了Java SE，当时使用的IDE是eclipse，由于这里主要介绍本人单片机课程的内容，代码是用C语言写的，所以就不对eclipse进行介绍了。</li>
</ul>
</li>
<li><p><strong>Keil 3</strong>：用来对代码进行编译和生成.HEX文件。</p>
<ul>
<li><a href="[https://baike.baidu.com/item/hex%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F](https://baike.baidu.com/item/hex文件格式)">hex文件格式</a>是可以烧写到单片机中，被单片机执行的一种文件格式。生成hex文件的方式有很多种，可以通过不同的编译器将C程序或者汇编程序编译生成hex,这里用的是Keil。</li>
</ul>
</li>
<li><p><strong>Proteus</strong>：EDA工具仿真软件，用来仿真单片机等器件。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>C51单片机</category>
      </categories>
      <tags>
        <tag>C51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/undefined/d95d7e09.html</url>
    <content><![CDATA[<h2 id="关于第一篇博客"><a href="#关于第一篇博客" class="headerlink" title="关于第一篇博客"></a>关于第一篇博客</h2><p>关于我创建这个博客的目的在关于一栏里有简单介绍，接下来这篇文章主要是写一下在我搭建博客过程中的心得吧。</p>
<p>首先本站是我搭建的第三个Hexo博客网站，那另外两个呢？另外两个因为操作过于萌新不满意搭建效果都删掉重来了QAQ。其实这第三个网站我费尽了千辛万苦才成功搭建起来，因为有前两个网站的搭建历史，导致我重新建第三个网站的时候经常出现克隆失败的情况，我当时都懵了，以为我不能再建Hexo博客了，不断地去查找资料寻找解决方案，最后终于在这条 <strong>强制清除缓存</strong> 指令<code>npm cache clean --force</code> 下让我重新成功搭建起Hexo博客，所以搭建不易，大家要好好爱惜自己辛苦搭建起来的博客网站啊。</p>
<p><img src="https://pic.downk.cc/item/5f3a9d7014195aa594b1fa04.png" alt="出错时的图片"></p>
<a id="more"></a>

<p>因为我的专业主要在嵌入式开发方向，只接触过C，Java和汇编语言，对JS和网页方面的知识不太了解，所以在搭建和完善本站的过程中出现了很多问题，比如主题、插入图片等问题，经常要花一部分时间去查找解决方案才能解决。在这里不得不说一下，真心想搭建好一个博客是需要花时间下功夫去摸索的，因为没有接触过JS和前端方面的知识做这个更是艰难，我只能尽自己所能把自己的博客做到自己满意的效果。</p>
<h2 id="Hexo博客搭建教程视频推荐"><a href="#Hexo博客搭建教程视频推荐" class="headerlink" title="Hexo博客搭建教程视频推荐"></a>Hexo博客搭建教程视频推荐</h2><p>首先我搭建的Hexo博客是参考了以下教程视频的，在这里可以给大家分享一下：</p>
<ul>
<li><p>使用Mac或者Linux来搭建的话，推荐 <a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener"><strong>CodeSheep</strong></a> 羊哥的视频， 传送门：<a href="https://www.bilibili.com/video/BV1Yb411a7ty" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411a7ty</a></p>
</li>
<li><p>使用windows搭建的话，我是看了<a href="https://space.bilibili.com/100518197/" target="_blank" rel="noopener"><strong>Master_lisa</strong></a>小姐姐的视频，每一步都特别详细（声音也很好听 /滑稽），传送门：<a href="https://www.bilibili.com/video/BV1A4411G7SF" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1A4411G7SF</a></p>
</li>
</ul>
<h2 id="聊一聊"><a href="#聊一聊" class="headerlink" title="聊一聊"></a>聊一聊</h2><h4 id="关于我的博客的发展"><a href="#关于我的博客的发展" class="headerlink" title="关于我的博客的发展"></a>关于我的博客的发展</h4><ul>
<li><p>会写一下关于现在专业知识学习时遇到的问题，可能会写一下学习过程中的心得吧。</p>
</li>
<li><p>有时间的话会写一下关于Hexo和Hugo博客搭建时遇到的问题，可能会有点教程内容，当然教程部分会用别人的来做参考，我会放出参考链接。</p>
</li>
<li><p>还有什么的话我会后续更新的…</p>
</li>
</ul>
<h4 id="我在Hexo和Hugo之间的选择"><a href="#我在Hexo和Hugo之间的选择" class="headerlink" title="我在Hexo和Hugo之间的选择"></a>我在Hexo和Hugo之间的选择</h4><p>大家都知道Hexo是基于Nodejs，Hugo是基于Go语言编写的。Hexo和Hugo之间各有优缺点，Hexo优点在于使用的人多，主题和插件多，正因如此，Hexo可以做很多美化工作，出现问题的话网上的解决方案会比较多，问题容易解决。但是它有个缺点，就是当文章数多了之后生成静态的速度会很慢，这个问题其实挺难受的。</p>
<p>而Hugo恰恰相反，主题和插件没有Hexo多，相应的教程就比较少。当然如果博客主要用途是用在写文章上，对主题美化要求不是特别高的话，这个问题是可以忽略不计的。其次，Hugo最大的优点就是生成静态的速度非常快，可能Hexo需要几分钟，而Hugo只需要几秒钟。</p>
<p>对于Hexo和Hugo之间的选择因人而异，在正式运用博客上我是想选择Hugo的，但是现在使用的是Hexo，这是因为一开始我接触到的教程是Hexo的，发现使用的人比较多我就也跟着做了，还有一点就是我对博客搭建方面的知识还不够充足，常常出现很多问题，查找解决方案的时候很方便。我也搭有一个Hugo的博客，本来是打算用它的，但是在主题方面出现了很多问题，去查问题也没查出来，所以只能先用着Hexo了。因为做博客确实花费了大量时间，后期有时间我慢慢去摸索吧。</p>
<h4 id="搭建个人博客的好处"><a href="#搭建个人博客的好处" class="headerlink" title="搭建个人博客的好处"></a>搭建个人博客的好处</h4><p>想必学习计算机方向的同学都知道搭建个人博客对未来找工作面试的时候会有很大的加分。还有我觉得可以对自己学习的知识进行总结和记录，方便今后的复习。在搭建博客的过程中查找问题解决方案时肯定会接触到别人的博客，别人的博客里面或许会有那么一两篇对你有用的干货，同时还可以接触到你没接触过的知识，不断拓展自己的知识层，俗话说：“技多不压身”，多了解一点或许在某个时候会对自己有帮助哦。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>第一篇写得太多了…… 今后我会不断完善这个博客的，接下来就请期待我不定期的更新吧哈哈哈</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
